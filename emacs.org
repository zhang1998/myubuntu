#+Title emacs 

* Emacs 快速指南.（查看版权声明请至本文末尾）
【注意：位于【】之间的内容是译注，比如本行，下同。】
Emacs 键盘命令通常包含 CONTROL 键（有时候以 CTRL 或 CTL 来标示）和 META 键（有时候用 EDIT 或 ALT 来标示）。为了避免每次都要写出全名，我们 约定使用下述缩写：

C-<chr> 表示当输入字符 <chr> 时按住 CONTROL 键。

因此 C-f 就表示：按住 CONTROL 键再输入 f。

 

M-<chr> 表示当输入字符 <chr> 时按住 META（或 EDIT 或 ALT）键。

如果你的键盘上没有 META 、EDIT 或 ALT 键，用下述方法也等效：

先按一下 ESC 键然后放开，再输入 <chr>。我们用 <ESC> 来表示

ESC 键。
重要提示：要退出 Emacs，请用 C-x C-c（两个连续的组合键）。 要退出一个正在运行中的命令，请用 C-g。 下文中左边顶行的“: >>”字样用来提示你尝试键盘命令。比如：
[本页当中特意留出一些空白是出于教学目的，请继续往后阅读]
>> 现在输入 C-v （查看下一屏文字）移动到下一屏。
（别紧张，在输入字符 v 的同时注意要按住 CONTROL 键） 从现在开始，每读完当前一屏你都需要这样做一次。
值得注意的是，当你从上一屏滚到下一屏时，中间会有两行的重复；这样做是为 了维持滚屏的连续性，方便你顺畅、连续地阅读。
用编辑器，开门第一件事就是学会在文字中移动。你已经知道了 C-v 可以向下移 动一屏，要往上移，请用 M-v （也就是按住 META 键，然后输入v，如果你没有 META、EDIT 或 ALT 键那么就先按 <ESC> 再按 v）。
>> 试试 M-v，然后再试试 C-v，来回遛几次。

*** 1 小结（SUMMARY）
以下命令在翻页浏览时相当有用：

C-v 向前移动一屏

M-v 向后移动一屏

C-l 重绘屏幕，并将光标所在行置于屏幕的中央

（注意是 CONTROL-L，不是 CONTROL-1）

>> 找到光标，留意其附近的文字，然后输入 C-l。
找找光标在哪里，你会发现其附近的文字与之前相同，位置却变为屏幕的中心。 如果你再次输入 C-l ，附近的文字将移动到屏幕的顶端。再次输入 C-l ， 文字将移动到底端。
如果你的键盘上有 PageUp 和 PageDn，也可以用这两个键来滚屏。不过使用 C-v 和 M-v 的效率要更高一些。
2 基本的光标控制（BASIC CURSOR CONTROL）
整屏的移动很有用，但是如何在文字中精确定位呢？
有几种方式可以选择。用方向键当然可以，不过更有效率的方法是保持双手位于 主键盘区，然后使用 C-p 、 C-b 、 C-f 和 C-n 这四个命令。它们的功能和方 向键是一样的，如下图所示:

上一行 C-p

:

:

向左移 C-b .... 目前光标位置 .... 向右移 C-f

:

:

下一行 C-n


>> 用 C-n 或 C-p 将光标移到上图的中央。

按 C-l，整幅图会被显示在屏幕的中央。

“P N B F”四个字母分别代表了四个词，用这四个词记忆这些组合键会更容易： P 代表 previous（上一行），N 代表 next（下一行），B 代表 backward（回 退），而 F 则代表 forward（前进）。这些组合键今后将与你形影不离。
>> 按几次 C-n 把光标往下挪到这里。
>> 用 C-f 把光标移动到这一行，然后再用 C-p 往上挪。
注意观察当光标在一行的中央时 C-p 命令的行为。
每行文字都以一个“换行符”结束，“换行符”把行与行区分开来。（通常情况下， 一个文件的最后一行会有一个换行符，但是 Emacs 不强制要求这一点。）
>> 在一行的行头输入 C-b。
光标应该会移动到前一行的行尾，因为光标在回退过程中越过了换行符。
同样 C-f 也可以像 C-b 一样越过换行符。
>> 连按几次 C-b，感受一下光标的移动。
然后按几次 C-f 回到本行的行尾。 再按一次 C-f，光标会移动到下一行。
当你移动光标穿越屏幕的上下边界时，在边界外的文字会移动到屏幕内，这称为 “滚动”（scrolling）。滚动使得光标可以被移动到文字中的任何位置，并且还 不会让光标跑到屏幕外边去。
>> 用 C-n 将光标下移，一直越过屏幕边界，同时观察发生了什么变化。
如果你嫌一个字符一个字符地挪光标太慢，你还可以一个词一个词地跳。M-f (META-f) 可以将光标往前移动一个词，而 M-b 则是往后移。【这里的“词”指 英文单词，对中文来说，则是指移动到下一个标点符号。】
>> 试试 M-f 和 M-b。
如果光标停在一个词的中间，M-f 会移动到这个词的末尾。如果光标处于词与词 之间的空白处，M-f 会移动到下一个词的末尾。M-b 的功能类似，只是方向相反。
>> 按几次 M-f 和 M-b，中间夹杂一些 C-f 和 C-b。
你可以观察到 M-f 和 M-b 在不同位置上所表现出来的不同行为。
请注意 C-f 、C-b 和 M-f 、M-b 两对之间的类比关系。通常的惯例是：META 系 列组合键用来操作“由语言定义的单位（比如词、句子、段落）”，而 CONTROL 系列组合键用来操作“与语言无关的基本单位（比如字符、行等等）”。
类似的惯例在“行”与“句子”之间也同样适用：C-a 和 C-e 可以将光标移动到 “一行”的头部和尾部；而 M-a 和 M-e 则将光标移动到“一句”的头部和尾部。
>> 按两次 C-a，再按两次 C-e。
按两次 M-a，再按两次 M-e。
想一想为什么重复的 C-a 命令会没有作用，而重复的 M-a 命令则会让光标不断 地回退到上一个句子。虽然这个类比规律并不严格，但是很自然。
光标停留的位置也可以称作“点位”（point）。或者干脆说，光标指示出了屏幕 上“点位”在文本中的位置。
这里对简单的光标移动命令做一个总结，其中也包括了整词和整句的移动：

C-f 向右移动一个字符

C-b 向左移动一个字符

 

M-f 向右移动一个词【对中文是移动到下一个标点符号】

M-b 向左移动一个词【对中文是移动到上一个标点符号】

 

C-n 移动到下一行

C-p 移动到上一行

 

C-a 移动到行首

C-e 移动到行尾

 

M-a 移动到句首

M-e 移动到句尾
>> 把上面所有的命令都练习几次，这些可都是最常用的命令。
这里还要介绍两个重要的光标移动命令：M-< （META 小于号）可以将光标移动到 所有文字的最开头；M-> （META 大于号）可以将光标移动到所有文字的最末尾。
注意，在大部分键盘上，小于号（<）需要用上档键（Shift）来输入，所以在这 些键盘上你应该用 Shift 键来输入 M-<，如果不按 Shift 键，你输入的会是 M-comma（META 逗号）。
>> 试一试 M-< ，移到本快速指南的最开始。
然后再按几次 C-v 回到这里。
>> 试一试 M-> ，移到本快速指南的最末尾。
然后再按几次 M-v 回到这里。
如果你的键盘上有方向键的话，也可以用它们来移动光标。不过我们有三个理由 推荐你学习 C-b 、C-f 、C-n 、和 C-p：（1）它们在任何键盘上都能用。（2） 当你熟练使用 Emacs 之后，你会发现用这些组合键比用方向键要快得多，因为你 的手不需要离开打字区。（3）一旦你习惯了使用这些组合键，你也可以很容易地 适应其它更高级的光标移动命令。
大部分的 Emacs 命令接受数字参数，并且对于多数命令而言，这些数字参数的作 用是指定命令的重复次数。为一个命令指定数字参数（也就是重复次数）的方法 是：先输入 C-u，然后输入数字作为参数，最后再输入命令。如果你有META （或 EDIT 或 ALT）键，那么还有另一种办法：按住 META 键不放，然后输入数字。不 过我们还是建议你用 C-u，因为它在任何终端机上都能用。这种数字参数也称为 “前缀参数”，意思是说这个参数是先于使用它的命令而输入的。
举例来说， C-u 8 C-f 会向前移动 8 个字符。
>> 为 C-n 或者 C-p 指定一个数字参数，这样你可以只用一个命令就把光标移动到本行的附近。
虽然大部分命令把数字参数解释为其重复次数，但是也有些命令例外，它们将数 字参数另做它用。比如有些命令（我们目前还没学到）仅仅将前缀参数作为一个 标志――只要给出有一个前缀参数，不管其值为何，它都会改变命令的功能。
而 C-v 和 M-v 则属于另一种类型的例外。当给定一个参数时，它们将滚动你指 定的“行数”，而不是“屏数”。举例来说，C-u 8 C-v 将文本向下滚动 8 行。
>> 现在试试看，输入 C-u 8 C-v。
这个命令应该已经将文字向上滚动了 8 行。如果你想将它再次地向下滚动，你可 以给定一个参数然后执行 M-v。
如果你正在使用图形界面，比如 X 或者微软的 Windows，那么在 Emacs窗 口的一边应该有一个长方形的区域叫“滚动条”。你可以用鼠标操纵滚动条来滚动 文字。
如果你的鼠标有滚轮的话，你也可以使用滚轮来滚动。
3 如果 EMACS 失去响应（IF EMACS STOPS RESPONDING）
如果 Emacs 对你的命令失去响应，你可以用 C-g 来安全地终止这条命令。C-g 也可以终止一条执行过久的命令。
C-g 还可以取消数字参数和只输入到一半的命令。
>> 输入 C-u 100 设定一个值为 100 的数字参数，然后按 C-g。
现在再按 C-f，光标应该只会移动一个字符，因为你已经用 C-g 取消了参数。
如果你不小心按了一下 <ESC>，你也可以用 C-g 来取消它。 【这个说法似乎有问题，因为按照这个按键顺序输入的应该是 C-M-g。 取消 <ESC> 的正确做法是再连按两次 <ESC>。】
4 被禁用的命令（DISABLED COMMANDS）
有一些 Emacs 命令被“禁用”了，以避免初学者在不了解其确切功能的情况下误 用而造成麻烦。
如果你用到了一个被禁用的命令，Emacs 会显示一个提示消息，告诉你这个命令 到底是干什么的，询问你是否要继续，并在得到你的肯定之后再执行这命令。
如果你真的想用这条命令，在 Emacs 询问你的时候应该按空格。一般来说，如果 你不想用，就按“n”。
>> 试试 C-x C-l （这是一个被禁用的命令）
然后用 n 来回答询问。
5 窗格（WINDOWS）
Emacs 可以有多个“窗格”，每个窗格显示不同的文字。后面会介绍怎么对付多个窗 格，现在我们先学会如何关掉多余的窗格。其实也很简单：
C-x 1 只保留一个窗格（也就是关掉其它所有窗格）。
也就是先按 CONTROL-x 然后再按 1。C-x 1 会保留光标所在的窗格，并将其扩大 到整个屏幕，同时关掉所有其它的窗格。
>> 把光标移到本行然后输入 C-u 0 C-l。
>> 输入 C-h k C-f。观察当一个新窗格出现时当前窗格（用来显示C-f 命令的文档）是如何缩小的。
>> 输入 C-x 1 关掉文档窗格。
有一系列命令是以 CONTROL-x 开始的，这些命令许多都跟“窗格、文件、缓冲区 【缓冲区（buffer）会在后文详细介绍】”等等诸如此类的东西有关，其中有些 命令可能包含了 2 个、3 个或者 4 个字符。
6 插入与删除（INSERTING AND DELETING）
插入文字很简单，直接敲键盘就可以了。普通的字符，比如 A、7、* 等等，会 随着你的输入而插入。要插入一个换行符，输入 <Return>（这个键在键盘上有 时会被标注成“Enter”）。
你可以用 <DEL> 来删除光标左边的字符，这个键通常被标注为“Backspace”――跟 你在 Emacs 之外的用法应该一样，删除最后一个输入的字符。
你的键盘上可能有另外一个键，标注着 <Delete>，但那个不是我们所说的 <DEL>。
>> 现在就来试试――敲点字，然后按几下 <DEL> 删除它们。
不用担心文件被修改，你做什么都没关系，这里就是专给你练习用的。
如果一行文字很长、超出了窗格的宽度，显示不下的部分会在紧邻的下一行继续 显示。如果你使用的是图形界面，文本区域两边的狭窄区域（左右“边缘”）会出 现小小的转弯箭头，表明这是某一行的接续显示。如果你使用的是文本终端，接 续显示由屏幕最右边一列的一个反斜线来表示。
>> 输入文字，一直到屏幕的右边界，然后继续。
你会看到一个接续行出现。
>> 用 <DEL> 删掉一些文字，直到此行长度小于窗格宽度，接续行就消失了。
换行符跟其它字符一样可以被删除。两行中间的换行符被删除后，这两行将会合 并成一行。如果合并后的这一行太长，超出了窗格宽度，它就会以一个接续行来 显示。
>> 移动光标到某行的开头并输入 <DEL>。
这时该行将与其前一行一起被合并为一行。
>> 输入 <Return> 重新插入你刚才删除的换行符。
前面讲过，大部分的 Emacs 命令都可以指定重复次数，这其中也包括输入字符的 命令。重复执行输入字符的命令实际上就是输入多个相同的字符。
>> 试试 C-u 8 *，这将会插入 ********。
好，现在你应该已经掌握了最基本的的文本插入和修改功能，其实删除还可以 “以词为单位”进行，下面是一个关于“删除”操作的小结：

<DEL> 删除光标前的一个字符

C-d 删除光标后的一个字符

 

M-<DEL> 移除光标前的一个词

M-d 移除光标后的一个词

 

C-k 移除从光标到“行尾”间的字符

M-k 移除从光标到“句尾”间的字符

【可能你已经注意到了“删除（delete）”和“移除（kill）”的用词区别，后 文会有详细说明。】
注意“<DEL> 和 C-d”还有“M-<DEL> 和 M-d”是根据前述惯例从 C-f和 M-f 衍生 出来的（其实<DEL>不是控制字符，我们先忽略这一点）。C-k和 M-k 的关系在 某种程度上与 C-e 和 M-e 一样――如果把“一行”和“一句”作一个类比的话。
你也可以用一种通用的办法来移除缓冲区里的任何一部分：首先把光标移动到你 想要移除的区域的一端，然后按 C-<SPC>（<SPC>指空格）【注意，C-<SPC> 往 往被中文用户设定成输入法热键，如果这样，C-<SPC> 就被系统拦截而无法传递 给 Emacs 了，在这种情况下可以使用C-@。】，然后将光标移动到你准备移除的 文字的另一端。这个时候， Emacs 会高亮光标和你按下 C-<SPC> 之间的文本。 最后，按下 C-w 。这样就可以把位于这两点之间的所有文字移除了。

>> 移动光标到上一段开头的“你”字。

>> 输入 C-<SPC> 。Emacs 应该会在屏幕的下方显示一个“Mark set”的消息。

>> 移动光标到第二行中的“端”字。

>> 输入 C-w，从“你”开始到“端”之前的文字被全部移除。

注意,“移除（kill）”和“删除（delete）”的不同在于被移除的东西可以被重新 插入（在任何位置），而被删除的就不能使用相同的方法重新插入了（不过可以 通过撤销一个删除命令来做到，后文会提到）。【实际上，移除掉的东西虽然看 起来“消失”了，但实际上被 Emacs 记录了下来，因此还可以找回来；而删除掉 的东西虽然也可能还在内存里，但是已经被 Emacs“抛弃”了，所以就找不回来 了。】重新插入被移除的文字称为“召回（yank）”。一般而言，那些可能消除很 多文字的命令会把消除掉的文字记录下来（它们被设定成了“可召回”），而那些 只消除一个字符或者只消除空白的命令就不会记录被消除的内容（自然你也就无 法召回了）。
>> 移动光标到一非空白行的行头，然后输入 C-k 移除那一行上的文字。
>> 再次 C-k，你可以看到它移除了跟在那一行后面的换行符。
注意，单独的 C-k 会把一行的内容移除，而第二个 C-k 则会移除换行符，并使 其后所有的行都向上移动。C-k 处理数字参数的方式很特别，它会把参数指定的 那么多行连同其后的换行符一起移除，而不仅仅是重复 C-k 而已。比如 C-u 2 C-k 会把两行以及它们的换行符移除；而如果只是输入 C-k 两次显然不是这个结 果。
重新插入被移除的文字恢复的动作称为“召回（yanking）”。（就好像把别人从你身边 移走的东西又猛力地拉回来。）你可以在你删除文字的地方召回，也可以在别的 地方召回，还可以多次召回同样的文字以得到它的多个拷贝。很多其它的编辑器 把移除和召回叫做“剪切”和“粘贴” （详情可见 Emacs 使用手册里的术语表）。
召回的命令是 C-y。它会在光标所在处插入你最后移除的文字。
>> 试试看，输入 C-y 将文字召回。
如果你一次连按了好几下 C-k，那么所有被移除的行会被存储在一起，只要一个 C-y 就可以把它们都召回。
>> 在这里试试，连续按几次 C-k。
现在再来恢复刚刚被我们移除的文字：
>> 按 C-y。然后把光标往下移动几行，再按一次 C-y。
现在你应该知道怎么复制文字了。
C-y 可以召回最近一次移除的内容，那如何召回前几次移除的内容呢？它们当然 没有丢，你可以用 M-y 来召回它们。在用 C-y 召回最近移除的文字之后，紧接 着再按 M-y 就可以召回再前一次被移除的内容，再按一次 M-y 又可以召回再上 一次的……连续使用 M-y 直到找到你想要召回的东西，然后什么也不用做，继续 编辑就行了。
如果连续按 M-y 很多次，你可能会回到起始点，也就是最近移除的文字。 【看得出这实际上是一个环。】

>> 移除一行，移动一下光标，然后再移除另外一行。

按 C-y 将第二次移除的那行召回来。

紧接着再按 M-y，它将会被第一次移除的那行取代。

试着再按几下 M-y 看看会发生什么。

再继续，直到第二行被召回来，然后再做个几次。

如果感兴趣，你可以试着给 M-y 指定一个正的或负的参数。

7 撤销（UNDO）
如果你修改了一段文字，又觉得改得不好，可以用 undo 命令进行撤销：C-/。
通常 C-/ 会消除一个命令所造成的所有改变；如果你在一行中连续多次地使用 C-/，你会把以前的命令也依次撤销。
但是有两个例外： 1） 没有改变文字的命令不算（包括光标移动命令和滚动命令） 2） 从键盘输入的字符以组为单位――每组最多 20 个字符――来进行处理。 （这是为了减少你在撤销“插入文字”动作时需要输入 C-/ 的次数）
>> 用 C-k 将这一行移除，然后输入 C-/ ，它会再次出现。
C-_ 也是撤销命令；它的作用跟 C-/ 一样，但是它比较容易多次输入。在 某些终端上，输入 C-/ 实际上向 Emacs 发送的是 C-_ 。 另外， C-x u 和 C-/ 完全一样，但是按起来有些麻烦。
数字参数对于 C-/ 、 C-_ 和 C-x u 的意义是执行撤销的重复次数。
8 文件（FILE）
想保存工作成果就要记得存盘，否则一旦退出 Emacs 你编辑的文字就会丢失。要 存盘，就要在编辑前“寻找”到一个存盘文件。（这个过程通常也被称为“访问” 文件。）
寻找到一个文件意味着你可以在 Emacs 里查看这个文件的内容。从许多角度看， 这就等于你在直接编辑这个文件，只是你所做的修改只有在“存盘”的时候才会 被写入文件。也正因为如此，你可以丢弃一个写到一半的文件而不必把这个残缺 文件也保存到计算机上。在存盘的时候，Emacs 会把存盘前的文件重命名保存， 以防你改完之后又想反悔。
在屏幕的下方，你应该能够看到头部有短线“-”的一行，行首通常是一些诸如“ -:— TUTORIAL.cn”的文字，这些文字代表了你当前正在访问的文件。比如你现 在正在访问的文件是对 Emacs 快速指南的一份临时拷贝，叫做“TUTORIAL.cn”。 每当Emacs 寻找到一个文件，文件名就会出现在这个位置。
寻找文件的命令有一个特点，那就是你必须给出文件名。我们称这个命令“读入 了一个参数”（在这里，这个参数显然就是文件名）。在你输入这条命令之后：
C-x C-f 寻找一个文件
Emacs 会提示你输入文件名。你输入的文件名会出现在屏幕最底端的一行，这一 行被称为小缓冲（minibuffer），在小缓冲里你可以使用通常的 Emacs 编辑命令 来编辑文件名。
在小缓冲里输入文件名（其实输入其它东西也一样）时可以用 C-g 取消。
>> 输入 C-x C-f，然后输入 C-g
这会关掉小缓冲，同时也会取消使用小缓冲的 C-x C-f 命令。 当然了，你也没有找任何文件。
用 <Return> 结束文件名的输入。之后，小缓冲会消失，C-x C-f 将会去寻找你 指定的文件。小缓冲在 C-x C-f 命令结束之后也会消失。
文件被显示在了屏幕上，你可以开始编辑了。存盘用这条命令：
C-x C-s 储存这个文件
这条命令把 Emacs 中的文字存储到文件中。第一次存盘的时候 Emacs 会将原文 件重命名以备份。重命名的规则通常是在原文件名之后添加一个“~”字符。 【对许多人来说，这是一个烦人的特性，关掉文件备份可以用如下命令： M-x customize-variable <Return> make-backup-files <Return>】
存盘结束后，Emacs 会显示写入文件的文件名。你最好养成经常存盘的习惯，这 可以减少系统崩溃和死机给你带来的损失（也可参见下面的“自动保存”一节）。
>> 输入 C-x C-s TUTORIAL.cn <Return> 。
这将会把该指南保存为一个名为 TUTORIAL.cn 的文件，并且在屏幕的下方显 示一条消息：“Wrote …TUTORIAL.cn”。
你不但可以寻找一个已有的文件来查看或编辑，还可以寻找一个不存在的文件。 实际上这正是 Emacs 创建新文件的方法：找到不存在的新文件。事实上，只有 在存盘的时候，Emacs 才会真正创建这个文件。而在这之后的一切就跟编辑一个 已有文件没有区别了。
9 缓冲区（BUFFER）
你可以用 C-x C-f 找到并打开第二个文件，但第一个文件仍然在 Emacs 中。要 切回第一个文件，一种办法是再用一次 C-x C-f。这样，你就可以在 Emacs 中同 时打开多个文件。
Emacs 把每个编辑中的文件都放在一个称为“缓冲区（buffer）”的地方。每寻 找到一个文件，Emacs 就在其内部开辟一个缓冲区。用下面的命令可以列出当前 所有的缓冲区：
C-x C-b 列出缓冲区
>> 现在就试一下 C-x C-b
观察一下缓冲区是如何被命名的，它很可能跟与其对应的文件同名。实际上，一 个 Emacs 窗格里的任何文字都是某个缓冲区的一部分。
>> 输入 C-x 1 离开缓冲区列表
不管存在多少缓冲区，任何时候都只能有一个“当前”缓冲区，也就是你正在编 辑的这个。如果你想编辑其它的缓冲区，就必须“切换”过去。上面讲过，用 C-x C-f 是一种办法。不过还有一个更简单的办法，那就是用 C-x b。用这条命 令，你必须输入缓冲区的名称。
>> 通过输入 C-x C-f foo <Return> 创建一个名为“foo”的文件。
然后输入 C-x b TUTORIAL.cn <Return> 回到这里。
大多数情况下，缓冲区与跟其对应的文件是同名的（不包括目录名），不过这也 不是绝对的。用 C-x C-b 得到的缓冲区列表总是显示缓冲区名。
缓冲区未必有对应文件。显示缓冲区列表的缓冲区（叫做“*Buffer List*”）就 是这样。这个 TUTORIAL.cn 缓冲区起初没有对应的文件，但是现在有了，因为 在前一节你输入了 C-x C-s ， 将它保存成了一个文件。
“*Messages*”缓冲区也没有对应文件，这个缓冲区里存放的都是在 Emacs 底部 出现的消息。
>> 输入 C-x b *Messages* <Return> 瞅瞅消息缓冲区里都有什么东西。
然后再输入 C-x b TUTORIAL.cn <Return> 回到这里。
如果你对某个文件做了些修改，然后切换到另一个文件，这个动作并不会帮你把 前一个文件存盘。对第一个文件的修改仍然仅存在于 Emacs 中，也就是在它对 应的缓冲区里。并且，对第二个文件的修改也不会影响到第一个文件。这很有用， 但也意味着你需要一个简便的办法来保存第一个文件的缓冲区。先切换回那个缓 冲区，再用 C-x C-s 存盘，太麻烦了。你需要一个更简便的方法，而 Emacs 已 经为你准备好了：
C-x s 保存多个缓冲区
C-x s 会找出所有已被修改但尚未存盘的缓冲区，然后向你逐个询问：是否需要 存盘？
>> 插入一行文字，然后输入 C-x s。
它应该会问你，是否要储存名为 TUTORIAL.cn 的缓冲区？ 按“y”告诉它你想存盘。
10 命令集扩展（EXTENDING THE COMMAND SET）
Emacs 的命令就像天上的星星，数也数不清。把它们都对应到 CONTROL 和 META 组合键上显然是不可能的。Emacs 用扩展（eXtend）命令来解决这个问题，扩展 命令有两种风格：

C-x 字符扩展。 C-x 之后输入另一个字符或者组合键。

M-x 命令名扩展。M-x 之后输入一个命令名。

很多扩展命令都相当有用，虽然与你已经学过的命令比起来，他们可能不那么常 用。我们早已经见过一些扩展命令了，比如用 C-x C-f 寻找文件和用 C-x C-s 保存文件；退出 Emacs 用的 C-x C-c 也是扩展命令。（不用担心退出 Emacs 会 给你带来什么损失，Emacs 会在退出之前提醒你存盘的。）
如果你使用图形界面，你不需要任何特殊的命令来切换 Emacs 和其他应用程序。 你可以使用鼠标或者窗口管理器的命令。然而，如果你使用只能同时显示一个应 用程序的文本终端，你需要“挂起” Emacs ，以切换到其他的应用程序。
C-z 可以暂时离开 Emacs――当然，你还可以再回来。在允许 C-z 的系统中，C-z 会把 Emacs“挂起”，也就是说，它会回到 shell但不杀死 Emacs 的进程。在常 用的 shell 中，通常可以用“fg”或者“%emacs”命令再次回到 Emacs 中。
你最好在打算退出登陆的时候再用 C-x C-c。在把 Emacs 当做一个临时的编辑 器的时候（比如被一个邮件处理程序调用），也可以用 C-x C-c 退出。
C-x 的扩展命令有很多，下面列出的是你已经学过的：

C-x C-f 寻找文件。

C-x C-s 保存文件。

C-x C-b 列出缓冲区。

C-x C-c 离开 Emacs。

C-x 1 关掉其它所有窗格，只保留一个。

C-x u 撤销。

用命令名扩展的命令通常并不常用，或只用在部分模式下。比如 replace-string（字符串替换）这个命令，它会把一个字符串替换成另一个。在 输入 M-x 之后，Emacs 会在屏幕底端向你询问并等待你输入命令名。如果你想 输入“replace-string”，其实只需要敲“repl s<TAB>”就行了，Emacs 会帮你自 动补齐。输入完之后按 <Return> 提交。
字符串替换命令需要两个参数――被替换的字符串和用来替换它的字符串。每个 参数的输入都以换行符来结束。
>> 将光标移到本行下面第二行的空白处，然后输入M-x repl s<Return>changed<Return>altered<Return>。
【以下保留一行原文，以应练习之需：】 Notice how this line has changed: you've replaced…
请注意这一行的变化：在光标之后的范围内，你已经将“changed”这个词――不 论它在哪里出现――全部用“altered”替换掉了。
11 自动保存（AUTO SAVE）
如果你已经修改了一个文件，但是还没来得及存盘你的计算机就罢工了，那么你 所做的修改就很可能会丢失。为了避免这样的不幸发生，Emacs 会定期将正在编 辑的文件写入一个“自动保存”文件中。自动保存文件的文件名的头尾各有一个 “#”字符，比如你正在编辑的文件叫“hello.c”，那么它的自动保存文件就叫 “#hello.c#”。这个文件会在正常存盘之后被 Emacs 删除。
所以，假如不幸真的发生了，你大可以从容地打开原来的文件（注意不是自动保 存文件）然后输入 M-x recover file <Return> 来恢复你的自动保存文件。在 提示确认的时候，输入 yes<Return>。
12 回显区（ECHO AREA）
如果 Emacs 发现你输入多字符命令的节奏很慢，它会在窗格的下方称为“回显区” 的地方给你提示。回显区位于屏幕的最下面一行。
13 状态栏（MODE LINE）
位于回显区正上方的一行被称为“状态栏”。状态栏上会显示一些信息，比如：
-:**- TUTORIAL.cn 63% L749 (Fundamental)
状态栏显示了 Emacs 的状态和你正在编辑的文字的一些信息。
你应该知道文件名的意思吧？就是你找到的那个文件嘛。-NN%– 显示的是光标在 全文中的位置。如果位于文件的开头，那么就显示 –Top– 而不是 –00%–；如 果位于文件的末尾，就显示 –Bot–。如果文件很小，一屏就足以显示全部内容， 那么状态栏会显示 –All–。
“L” 和其后的数字给出了光标所在行的行号。
最开头的星号（*）表示你已经对文字做过改动。刚刚打开的文件肯定没有被改动 过，所以状态栏上显示的不是星号而是短线（-）。
状态栏上小括号里的内容告诉你当前正在使用的编辑模式。缺省的模式是 Fundamental，就是你现在正在使用的这个。它是一种“主模式”。
Emacs 的主模式林林总总。有用来编辑程序代码的――比如 Lisp 模式；也有用 来编辑各种自然语言文本的――比如 Text 模式。任何情况下只能应用一个主模 式，其名称会显示在状态栏上，也就是现在显示“Fundamental”的地方。
主模式通常会改变一些命令的行为。比方说，不管编辑什么语言的程序代码，你 都可以用一个相同的命令来添加注释。但是在不同的语言中注释的语法往往是不 同的，这时不同的主模式就会用各自不同的语法规则来添加注释。主模式都是可 以用 M-x 启动的扩展命令，M-x fundamental-mode 就可以切换到 Fundamental 模式。
编辑自然语言文本――比如现在――应该用 Text 模式。
>> 输入 M-x text-mode <Return>。
别担心，什么都没变。不过细心一些可以发现，M-f 和 M-b 现在把单引号（'） 视为词的一部分了。而在先前的 Fundamental 模式中，M-f 和 M-b 都将单引号 视为分隔单词的符号。
主模式通常都会搞一些类似的小动作，因为很多命令其实完成的是“相同的工 作”，只是在不同环境下会有不同的工作方式而已。【所谓“求同存异”，在 Emacs 里得到了很好的体现】
用 C-h m 可以查看当前主模式的文档。

>> 把光标移动到下一行。

>> 用 C-l C-l 将本行带到屏幕的最上方。

>> 输入 C-h m，看看 Text 模式与 Fundamental 模式有哪些不同。

>> 输入 C-x 1 关掉文档窗格。

主模式之所以称之为“主（major）”模式，是因为同时还有“辅模式”（minor mode）存在。辅模式并不能替代主模式，而是提供一些辅助的功能。每个辅模式 都可以独立地开启和关闭，跟其它辅模式无关，跟主模式也无关。所以你可以不 使用辅模式，也可以只使用一个或同时使用多个辅模式。
有一个叫做自动折行（Auto Fill）的辅模式很有用，特别是在编辑自然语言文本 的时候。启用自动折行后，Emacs 会在你打字超出一行边界时自动替你换行。
用 M-x auto-fill-mode <Return> 启动自动折行模式。再用一次这条命令，自 动折行模式会被关闭。也就是说，如果自动折行模式没有被开启，这个命令会开 启它；如果已经开启了，这个命令会关闭它。所以我们说，这个命令可以用来 “开关（toggle）”模式。
>> 现在输入 M-x auto-fill-mode <Return>。然后随便敲点什么，直到你看到它
分成两行。你必须敲一些空格，因为 Auto Fill 只在空白处进行断行。 【输入空格对英文来说是必须的，而对中文则不必。】
行边界通常被设定为 70 个字符【这里指英文字符】，你可以用 C-x f 命令配合 数字参数来重新设定它。
>> 输入 C-x f 并传递参数 20： C-u 2 0 C-x f。
然后输入一些文字，观察 Emacs 的自动折行动作 最后再用 C-x f 将边界设回 70。
如果你在段落的中间做了一些修改，那么自动折行模式不会替你把整个段落重新 折行，你需要用 M-q 手动折行。注意，光标必须位于你需要折行的那一段里。
>> 移动光标到前一段中，然后输入 M-q。
14 搜索（SEARCHING）
Emacs 可以向前或向后搜索字符串（“字符串”指的是一组连续的字符）。搜索命 令是一个移动光标的命令：搜索成功后，光标会停留在搜索目标出现的地方。
Emacs 的搜索命令是“渐进的（incremental）”。意思是搜索与输入同时进行： 你在键盘上一字一句地输入搜索词的过程中，Emacs 就已经开始替你搜索了。
C-s 是向前搜索，C-r 是向后搜索。不过手别这么快！别着急试。
在按下 C-s 之后，回显区里会有“I-search”字样出现，表明目前 Emacs 正处 于“渐进搜索”状态，并等待你输入搜索字串。按 <Return> 可以结束搜索。
>> 输入 C-s 开始一个搜索。注意敲慢一点，一次输入一个字符。
慢慢输入“cursor”这个词，每敲一个字都停顿一下并观察光标。 现在你应该已曾经找到“cursor”这个词了。

>> 再按一次 C-s，搜索下一个“cursor”出现的位置。

>> 现在按四次 <DEL> ，看看光标是如何移动的。

>> 敲 <Return> 结束搜索。

看仔细了么？在一次渐进式搜索中，Emacs 会尝试跳到搜索目标出现的位置。要 跳到下一个命中位置，就再按一次 C-s。如果找不到目标，Emacs 会发出“哔” 的一声，告诉你搜索失败。在整个过程中，都可以用 C-g 来终止搜索。【你会发 现 C-g 会让光标回到搜索开始的位置，而 <Return> 则让光标留在搜索结果上， 这是很有用的功能。】
在渐进式搜索中，按 <DEL> 会“撤回”到最近一次搜索的命中位置。如果之前没 有一个命中， <DEL> 会抹去搜索字符串中的最后一个字符。比如你已经输入了 “c”，光标就停在“c”第一次出现的位置，再输入“u”，光标停在“cu”第一次出现 的位置，这时再按 <DEL> ，“u”就从搜索字串中消失了，然后光标会回到“c”第 一次出现的位置。
另外，如果你在搜索的时候输入了 control 或者 meta 组合键的话，搜索可能会 结束。（也有例外，比如 C-s 和 C-r 这些用于搜索的命令。）
前面说的都是“向下”搜索，如果想“向上”搜索，可以用 C-r。C-r 与 C-s 相比除了搜索方向相反之外，其余的操作都一样。
15 多窗格（MULTIPLE WINDOWS）
Emacs 的迷人之处很多，能够在屏幕上同时显示多个窗格就是其中之一。
>> 移动光标到这一行，然后输入 C-l C-l。
>> 现在输入 C-x 2，它会将屏幕划分成两个窗格。
这两个窗格里显示的都是本篇快速指南，而光标则停留在上方的窗格里。
>> 试试用 C-M-v 滚动下方的窗格。
（如果你并没有 META 键，用 ESC C-v 也可以。） 【向上滚动是 C-M-S-v，也就是同时按住 CONTROL、META 和 SHIFT 再按 v】
>> 输入 C-x o（“o”指的是“其它（other）”），
将光标转移到下方的窗格。
>> 在下方的窗格中，用 C-v 和 M-v 来滚动。
同时继续在上方的窗格里阅读这些指导。
>> 再输入 C-x o 将光标移回到上方的窗格里。
光标会回到它在上方窗格中原本所在的位置。
连续使用 C-x o 可以遍历所有窗格。“被选中的窗格”，也就是绝大多数的编辑 操作所发生的地方，是在你不打字时闪烁光标的那个窗格。其他的窗格有它们自 己的光标位置； 如果你在图形界面下运行 Emacs ，这些光标是镂空的长方形。
当你在一个窗格中编辑，但用另一个窗格作为参考的时候，C-M-v 是很有用的命 令。无需离开被选中的窗格，你就可以用 C-M-v 命令滚动另外一个窗格中的文 字。【比如翻译和校对就很适合用这种方式进行。】
C-M-v 是一个 CONTROL-META 组合键。如果你有 META （或 Alt）键的话，可以 同时按住CONTROL 和 META 键并输入 v。CONTROL 和 META 键先按哪个都可以， 因为它们只是用来“修饰（modify）”你输入的字符的。
如果你并没有 META 键，你也可以用 ESC 来代替，不过这样的话就要注意按键顺 序了：你必须先输入 ESC ，然后再输入 CONTROL-v。CONTROL-ESC v 是没用的， 因为 ESC 本身是一个字符键，而不是一个修饰键（modifier key）。
>> （在上方窗格里）输入 C-x 1 关掉下方窗格。
（如果你在下方的窗格里输入 C-x 1，那么就会关掉上方的窗格。你可以把这个 命令看成是“只保留一个窗格”――就是我们正在编辑的这个。）
不同的窗格可以显示不同的缓冲区。如果你在一个窗格里用 C-x C-f 打开了一个 文件，另一个窗格并不会发生什么变化。任何一个窗格里都可以用来打开文件。
用下面的方法可以在一个新开窗格里打开文件：
>> 输入 C-x 4 C-f，紧跟着输入一个文件名，再用 <Return> 结束。
可以看到你指定的文件出现在下方的窗格中，同时光标也跳到了那里。
>> 输入 C-x o 回到上方的窗格，然后再用 C-x 1 关掉下方窗格。
16 多窗口（MULTIPLE FRAMES）
Emacs 可以创建多个窗口。窗口由许多窗格以及菜单、滚动条、回显区等组成。 在图形界面下，多个窗口可以同时显示出来。在文本终端中，只能同时显示一个 窗口。
>> 输入 M-x make-frame <Return>。
可以看到一个新的窗口出现在了你的屏幕上。
你可以在新的窗口里做最初的窗口里可以做的任何事情。第一个窗口没有什么特 别的。
>> 输入 M-x delete-frame <Return>.
这个命令将会关闭选中的窗口。
你也可以通过图形系统来关闭某个窗口（通常是在窗口上面的某个角落里的一个 “X”按钮）。如果你关闭的是 Emacs 进程的最后一个窗口， Emacs 将会退出。
17 递归编辑（RECURSIVE EDITING LEVELS）
有时候你会进入所谓的“递归编辑”。递归编辑状态由位于状态栏的方括号所指 示，其中包含了用小括号来指明的模式名称。比如说，你有时可能会看到 [(Fundamental)]，而不是 (Fundamental)。【比如在用 M-% 进行交互式替换的 时候你又用了 C-s 进行搜索，这时替换模式并没有结束，但你又进入了搜索模式， 这就是所谓的递归编辑。】
离开递归编辑可以用 ESC ESC ESC。这是一个最通用的“离开”命令，你甚至可 以使用它来关掉多余的窗格，或者离开小缓冲。
>> 输入 M-x 进入小缓冲；然后输入 ESC ESC ESC 离开。
你不能用 C-g 退出递归编辑，因为 C-g 的作用是取消“本层递归编辑之内”的 命令和其参数（arguments）。
18 获得更多帮助（GETTING MORE HELP）
本快速指南的目的仅仅是帮助你在 Emacs 的海洋里下水，不至于束手无策望洋兴 叹。有关 Emacs 的话题可谓汗牛充栋，这里自然是难尽万一。不过 Emacs 很理 解你求知若渴的心情，因为它提供的强大功能实在是太多了。为此，Emacs 提供 了一些命令来查看 Emacs 的命令文档，这些命令都以 CONTROL-h 开头，这个字 符也因此被称为“帮助（Help）字符”。
要使用帮助（Help）功能，请先输入 C-h，然后再输入一个字符以说明你需要什 么帮助。如果你连自己到底需要什么帮助都不知道，那么就输入 C-h ?，Emacs 会告诉你它能提供了哪些帮助。如果你按了 C-h 又想反悔，可以用 C-g 取消。
（如果你按 C-h 之后没有任何帮助信息显示出来，那么试试 F1 键或者 M-x help <Return> 。）
最基本的帮助功能是 C-h c。输入 C-h c 之后再输入一个组合键，Emacs 会给出 这个命令的简要说明。
>> 输入 C-h c C-p。
显示的消息应该会是这样：
C-p runs the command previous-line
这条消息显示了 C-p 命令对应的函数名。命令的功能由函数完成，所以函数名 本身也可以被看成是最简单的文档――至少对于你已经学过的命令来说，它们的函 数名足以解释它们的功能了。
多字符命令一样可以用 C-h c 来查看。
想得到更多的信息，请把 C-h c 换成 C-h k 试试看。
>> 输入 C-h k C-p。
上面的命令会新打开一个 Emacs 窗格以显示函数的名称及其文档。你读完之后可 以用 C-x 1 关掉这个帮助窗格。当然你并不需要立即这样做，你完全可以先在编 辑窗格里做点别的事情，然后再关掉帮助窗格。
还有一些其它有用的 C-h 命令：
C-h f 解释一个函数。需要输入函数名。
>> 试试看，输入 C-h f previous-line <Return>。
Emacs 会给出它所知道的所有有关“实现 C-p 命令功能的函数”的信息。
C-h v 用来显示 Emacs 变量的文档。Emacs 变量可以被用来“定制 Emacs 的行 为”。同样，你需要输入变量的名称。
C-h a 相关命令搜索（Command Apropos）。 输入一个关键词然后 Emacs 会列出所有命令名中包含此关键词 的命令。这些命令全都可以用 M-x 来启动。对于某些命令来说， 相关命令搜索还会列出一两个组合键。
>> 输入 C-h a file <Return>。
Emacs 会在另一个窗格里显示一个 M-x 命令列表，这个列表包含了所有名称中含 有“file”的命令。你可以看到像“C-x C-f”这样的组合键显示在“find-file” 这样的命令名的旁边。
>> 用 C-M-v 来回滚动 help 窗格，多试几次。
>> 输入 C-x 1 来删除 help 窗格。
C-h i 阅读手册（也就是通常讲的 Info）。 这个命令会打开一个称为“*info*”的特殊缓冲区，在那里， 你可以阅读安装在系统里的软件包使用手册。要读 Emacs 的使 用手册，按 m emacs <Return> 就可以了。如果你之前从没用 过 Info 系统，那么请按“?”，Emacs 会带你进入 Info 的使 用指南。在看完本快速指南之后，Emacs Info 会成为你的主要 参考文档。
19 更多精彩（MORE FEATURES）
想学习更多的使用技巧，Emacs 使用手册（manual）值得一读。你可以读纸版的 书，也可以在 Emacs 中读（可以从 Help 菜单进入或者按 C-h r）。提两个你 可能会很感兴趣的功能吧，一个是可以帮你少敲键盘的 completion（自动补全）， 另一个是方便文件处理的 dired（目录编辑）。
Completion 可以替你节省不必要的键盘输入。比如说你想切换到 Message 缓 冲区，你就可以用 C-x b *M<Tab> 来完成。只要 Emacs 能够根据你已经输入的 文字确定你想要输入的内容，它就会自动帮你补齐。Completion 也可用于命令 名和文件名。有关 Completion 的详细说明可以在 Emacs Info 中的 “Completion”一节里找到。
Dired 能够在一个缓冲区里列出一个目录下的所有文件（可以选择是否也列出子 目录），然后你可以在这个文件列表上完成对文件的移动、访问、重命名或删除 等等操作。Dired 也在 Emacs 使用手册中有详细介绍，参见“Dired”一节。
Emacs 使用手册里还有许许多多的精彩功能等着你来了解。
20 总结（CONCLUSION）
要退出 Emacs 请用 C-x C-c。
本文完全是为零起点新手所写的起步教程。如果你觉得哪里还看不明白，千万不 要怀疑自己，那一定是我们没有写好。我们永远欢迎你的不满和抱怨。
21 翻译（TRANSLATION）
翻译：孙一江 <sunyijiang@gmail.com> 维护：薛富侨 <xfq.free@gmail.com> 校对：水木社区（www.newsmth.net）Emacs 板众多网友及众多 Emacs 中文用户
Emacs 快速指南（Tutorial）早有两个刘昭宏的中文译本，繁简各一。其简体版本 （TUTORIAL.cn）基本由繁体版本（TUTORIAL.zh）经词语替换而得。然而繁简中文 不仅在用词习惯上有所不同，更有诸多表达方式与句法方面的差异，因此一直以来 用户使用 TUTORIAL.cn 都会略觉生硬和晦涩。这次重新翻译 TUTORIAL.cn 的动机 正是源于这种体验，希望我们的工作能够让本文更好地发挥其作用。TUTORIAL.zh 的译文质量很高，在翻译过程中给予过我们许多借鉴和参考，在此对刘昭宏的工作 表示感谢。
翻译过程中最大的挑战莫过于术语译词的选择了。经过水木社区 Emacs 板热心 网友小范围内的讨论，我们选择了现在的译法。用户的广泛参与是自由软件生命 力的源泉，所以如果你有任何建议、勘误或想法，请用你喜欢的方式向我们提出。 你可以通过电子邮件直接联系维护者，也可以放到 GNU Emacs 的开发邮件列表 或者水木社区的 Emacs 板上进行讨论。
下面列出主要术语的译词对照，并给出注释说明：

command 命令

cursor 光标

scrolling 滚动

numeric argument 数字参数

window 窗格 [1]

insert 插入

delete 删除 [2]

kill 移除 [2]

yank 召回 [2]

undo 撤销

file 文件

buffer 缓冲区

minibuffer 小缓冲

echo area 回显区

mode line 状态栏

search 搜索

incremental search 渐进式搜索 [3]

对于其他没有提到的术语，读者可以参考 Emacs 使用手册里的术语表。
22 版权声明（COPYING）
This tutorial descends from a long line of Emacs tutorials starting with the one written by Stuart Cracraft for the original Emacs.
This version of the tutorial is a part of GNU Emacs. It is copyrighted and comes with permission to distribute copies on certain conditions:
Copyright (C) 1985, 1996, 1998, 2001-2014 Free Software Foundation, Inc.
This file is part of GNU Emacs.
GNU Emacs is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with GNU Emacs. If not, see http://www.gnu.org/licenses/.
Please read the file COPYING and then do give copies of GNU Emacs to your friends. Help stamp out software obstructionism ("ownership") by using, writing, and sharing free software!
【下面为版权声明的译文，仅供参考。实际法律效力以英文原文为准。】
本快速指南沿袭自历史悠久的 Emacs 快速指南，可上溯至 Stuart Cracraft 为最 初的 Emacs 所作的版本。
本篇指南是 GNU Emacs 的一部分，并允许在下列条件的约束下发行其拷贝：
Copyright (C) 1985, 1996, 1998, 2001-2014 Free Software Foundation, Inc.
本文件为 GNU Emacs 的一部分。
GNU Emacs 为自由软件；您可依据自由软件基金会所发表的GNU通用公共授权 条款，对本程序再次发布和/或修改；无论您依据的是本授权的第三版，或 （您可选的）任一日后发行的版本。
GNU Emacs 是基于使用目的而加以发布，然而不负任何担保责任；亦无对适 售性或特定目的适用性所为的默示性担保。详情请参照GNU通用公共授权。
您应已收到附随于 GNU Emacs 的GNU通用公共授权的副本；如果没有，请参照 http://www.gnu.org/licenses/.
敬请阅读文件“COPYING”，然后向你的朋友们分发 GNU Emacs 拷贝。让我们以使 用、编写和分享自由软件的实际行动来共同祛除软件障碍主义（所谓的“所有 权”）！



* WAITING 学习purcell的顶尖配置 [2/2]
:LOGBOOK:  
- State "WAITING"    from "WAITING"    [2018-12-19 三 21:10]
- State "WAITING"    from "TODO"       [2018-12-19 三 21:05] \\
  目前暂时没有什么可以继续的部分，比如ide的全面配置等等，因为不写java和c等程序，暂时没有需求，自己写python'目前都是单文件也挺好的。
:END:      
*** DONE orgmode [2/2]
CLOSED: [2018-12-19 三 18:49]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 18:49]
:END:      
*** DONE 自动折行 [/]
CLOSED: [2018-12-19 三 18:48]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 18:48]
:END:      
*** DONE todo
CLOSED: [2018-12-19 三 18:49]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 18:49]
:END:      
*** DONE 编辑器功能
CLOSED: [2018-12-19 三 21:04]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 21:04]
:END:      
*** DONE TDDO 补全
CLOSED: [2018-12-19 三 18:55]
:LOGBOOK:  
- State "DONE"       from ""           [2018-12-19 三 18:55]
:END:      
*** java 
*** DONE python
CLOSED: [2018-12-19 三 18:49]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 18:49]
:END:      
***  c


* 网络浏览

| 浏览器 | 引擎 | 标签页 | 直接搜索 | 速度 | 浏览问题 | 保存网页 | 保存网址 | other  | 图片 | 文库 |
| w3m    | 测试 | 多     | 能       | 慢   | 重复刷新 | ok       | ok       |        | 支持 | 不   |
| eww    | 失败 | no     | 能       | 中   |          |          | ok       |        | 支持 | 不   |
| [[https://www.emacswiki.org/emacs/w3][w3]]     |      |        |          |      |          |          |          | 不会用 |      |      |
|        |      |        |          |      |          |          |          |        |      |      |
*** 关于w3m
重复刷新问题通过避免使用百度解决。
修改引擎：

*** eww的问题与期望
复制粘贴 ok
搜索引擎 
直接搜索
多标签页

* 配置问题
stardict问题 如何启动.....
输入sudo  emacsui不支持输入法ssddff ddd
不输入sudo  启动shell一片空白 d 
想init.el写入注释#\\#时候报错，不知道为什么。

** TODO 加入印象笔记   或者  丰富的手机支持
用c就可以  全是语句判断
* 终端
emacs的终端属于哑终端，在安装一些软件的时候，不能配置图形界面，因此安装软件不要从这里开始
* 使用purcell中遇到的问题
[[http://blog.sina.com.cn/s/blog_1313062e90102w0oi.html][在这里开始Steve Purcell]]
*** 网络不通 
最后注意修改网络：
   3.更改.emacs.d/lisp/init-elpa.el
   ;;; Standard package repositories
   (add-to-list 'package-archives
   '("popkit" . "https://elpa.popkit.org/packages/"))

*** 链接超时 
升级大神配置遇到的问题：Warning (initialization): // An error occurred while loading ‘/home/work/.emacs.d/init.el’:
File error: Failed connect, 连接超时

To ensure normal operation, you should investigate and remove the
cause of the error in your initialization file.  Start Emacs with
the ‘--debug-init’ option to view a complete error backtrace.

查看debug之后：Debugger entered--Lisp error: (error "Selecting deleted buffer")
  signal(error ("Selecting deleted buffer"))
  package-install-from-archive([cl-struct-package-desc mmm-mode (0 5 7) "Allow Multiple Major Modes in a buffer" ((cl-lib (0 2))) tar "gnu" nil ((:keywords "convenience" "faces" "languages" "tools") (:url . "https://github.com/purcell/mmm-mode")) nil])
  mapc(package-install-from-archive ([cl-struct-package-desc mmm-mode (0 5 7) "Allow Multiple Major Modes in a buffer" ((cl-lib (0 2))) tar "gnu" nil ((:keywords "convenience" "faces" "languages" "tools") (:url . "https://github.com/purcell/mmm-mode")) nil]))
  package-download-transaction(([cl-struct-package-desc mmm-mode (0 5 7) "Allow Multiple Major Modes in a buffer" ((cl-lib (0 2))) tar "gnu" nil ((:keywords "convenience" "faces" "languages" "tools") (:url . "https://github.com/purcell/mmm-mode")) nil]))
  package-install(mmm-mode)
  (if (cl-find-if (function (lambda (v) (version-list-<= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t)))
  (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-<= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t))))
  (or (package-installed-p package min-version) (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-<= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t)))))
  (lambda (package &optional min-version no-refresh) "Install given PACKAGE, optionally requiring MIN-VERSION.\nIf NO-REFRESH is non-nil, the available package lists will not be\nre-downloaded in order to locate PACKAGE." (or (package-installed-p package min-version) (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-<= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t))))))(mmm-mode)
  apply((lambda (package &optional min-version no-refresh) "Install given PACKAGE, optionally requiring MIN-VERSION.\nIf NO-REFRESH is non-nil, the available package lists will not be\nre-downloaded in order to locate PACKAGE." (or (package-installed-p package min-version) (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-<= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t)))))) mmm-mode nil)
  (let ((available (apply oldfun package args))) (prog1 available (if (and available (boundp (quote package-selected-packages))) (progn (add-to-list (quote sanityinc/required-packages) package)))))
  sanityinc/note-selected-package((lambda (package &optional min-version no-refresh) "Install given PACKAGE, optionally requiring MIN-VERSION.\nIf NO-REFRESH is non-nil, the available package lists will not be\nre-downloaded in order to locate PACKAGE." (or (package-installed-p package min-version) (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-<= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t)))))) mmm-mode)
  apply(equiring MIN-VERSION.\nIf NO-REFRESH is non-nil, the available package lists will not be\nre-downloaded in order to locate PACKAGE." (or (package-installed-p package min-version) (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-<= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t)))))) mmm-mode)
  require-package(mmm-mode)
  eval-buffer(#<buffer  *load*-174381> nil "/home/work/.emacs.d/lisp/init-mmm.el" nil t)  ; Reading at buffer position 210
  load-with-code-conversion("/home/work/.emacs.d/lisp/init-mmm.el" "/home/work/.emacs.d/lisp/init-mmm.el" nil t)
  #<subr require>(init-mmm)
  apply(#<subr require> init-mmm nil)
  (prog1 (apply orig feature args) (if (and (not already-loaded) (memq feature features)) (progn (let ((time (sanityinc/time-subtract-millis (current-time) require-start-time))) (add-to-list (quote sanityinc/require-times) (list feature require-start-time time) t)))))
  (let* ((already-loaded (memq feature features)) (require-start-time (and (not already-loaded) (current-time)))) (prog1 (apply orig feature args) (if (and (not already-loaded) (memq feature features)) (progn (let ((time (sanityinc/time-subtract-millis ... require-start-time))) (add-to-list (quote sanityinc/require-times) (list feature require-start-time time) t))))))
  sanityinc/require-times-wrapper(#<subr require> init-mmm)
  apply(sanityinc/require-times-wrapper #<subr require> init-mmm)
  require(init-mmm)
  eval-buffer(#<buffer  *load*> nil "/home/work/.emacs.d/init.el" nil t)  ; Reading at buffer position 2748
  load-with-code-conversion("/home/work/.emacs.d/init.el" "/home/work/.emacs.d/init.el" t t)
  load("/home/work/.emacs.d/init" t t)
  #[0 "\205\266\00	\306=\203\00\307\310Q\202?\00	\311=\204\00\307\312Q\202?\00\313\307\314\315#\203*\00\316\202?\00\313\307\314\317#\203>\00\320\321\322!D\nB\323\202?\00\316\324\325\324\211#\210\324=\203e\00\326\327\330\307\331Q!\"\325\324\211#\210\324=\203d\00\210\203\247\00\332!\333\232\203\247\00\334!\211\335P\336!\203\201\00\211\202\214\00\336!\203\213\00\202\214\00\314\262\203\245\00\337\"\203\243\00\340\341#\210\342\343!\210\266\f?\205\264\00\314\325\344\324\211#)\262\207" [init-file-user system-type delayed-warnings-list user-init-file inhibit-default-init inhibit-startup-screen ms-dos "~" "/_emacs" windows-nt "/.emacs" directory-files nil "^\\.emacs\\(\\.elc?\\)?$" "~/.emacs" "^_emacs\\(\\.elc?\\)?$" initialization format-message "`_emacs' init file is deprecated, please use `.emacs'" "~/_emacs" t load expand-file-name "init" file-name-as-directory "/.emacs.d" file-name-extension "elc" file-name-sans-extension ".el" file-exists-p file-newer-than-file-p message "Warning: %s is newer than %s" sit-for 1 "default"] 7]()
  command-line()
  normal-top-level()

*** font tty not defined
具体问题是由于emacs的bug导致的（以24版本作为代表），由于进入shell之后会保存用户信息到tty最终生成了此结果，

具体描述在github purcell/emacs.d/issues/259
问题发生在进入shell之后再进入gun

***** 解决方案
运行：
#+BEGIN_SRC 
emacsclient -nw& 到client停止即可

#+END_SRC
* 随笔
* emacs加上宏
1. 为宏命名：M-x name-last-kdb-macro
2. 在配置文件的某个地方输入 M-x insert-kdb-macro
3.  然后可以通过m-x调用

我是直接通过1.2.完成的
*** TODO 还缺乏绑定
*** DONE 本次保存的test1下次还有吗?
CLOSED: [2019-06-01 六 11:35] SCHEDULED: <2019-06-01 六>
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-06-01 六 11:35]
:END:      
我的方法没有了

* TODO 查看我的emacs到底都有什么可能
- org文档部分
- 编程  以python为例

* DONE 插件推荐
CLOSED: [2018-12-19 三 19:01]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 19:01]
:END:      
[[https://linux.cn/article-6891-1.html][桌面应用：暴增生产力]]
虽然我主要侧重于与编程相关的生产力提升，但是这些插件对所有人或不同用途                                                                                                                        
** 1. Ido-mode                                                                                                          
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
Ido 或许是对新手最有用的一个插件，Ido 的意思是交互式工作（                                                           
interactively do）。它取代了大部分的用花哨字符匹配菜单的枯燥提示。好比                                               
说，它用列出了当前目录所有文件的列表来取代了常规的打开文件提示符。输入                                               
一些字符，Ido 将尝试匹配最合适的文件。它通过可视化让你的操作变得更容易                                               
，这也是一个快速遍历所有文件都有相同前缀的文件夹的方法。                                                             

** 2. Smex                                                                                                              
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
它不算最著名的一个、但却是一个替代 Ido-mode 的好选择：Smex 可以优雅的                                                
替代普通的M-x提示符，灵感大部分来自于 Ido-mode。它也给调用M-x后输入的                                                
命令带来了同样的交互搜索能力。它简单而有效，是一个为常用操作提升效率的                                               
最好方法。                                                                                                           

** 3. Auto Complete                                                                                                     
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
知道这个插件的存在之前，我在 Emacs 里面有一半的时间花在敲击 M-/ 来补完                                               
单词上。现在，我有一个漂亮的弹出菜单可以为我做自动补全。无须多说，我们                                               
都需要它。                                                                                                           

** TODO [#C] 4. YASnippet                                                                                                         
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
这是真正的程序员必备利器。总有一些代码片段会让我们觉得我们一辈子都在写                                               
它。对我来说，就是调试 PHP 时不断输入的 var_dump(...);exit;。经过一段                                                
时间一遍又一遍的输入var_dump(...);exit;，我觉得我可以预先把其做成录制                                                
好的、方便用到的代码片段。使用 YASnippets，可以很容易导入代码片段文件                                                
或者自己做个。之后，只要按下一个 tab 键，就可以将一个小的关键词扩展成                                                
一大段预先写好的代码，然后可以很方便地在里面修改。                                                                   

** 5. Org-mode                                                                                                          
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
免责声明，我最近才开始使用 Org-mode，但它已经深深的吸引了我。从我看过                                                
数以百计的文章来说，Org-mode 可以改变你的生活。它背后的想法很简单：它                                                
是一种用普通文本做简单备注的模式，可以很容易地在任务列表和各种数据中转                                               
来转去，并进行一些比如按优先级或到期日期的过滤，或设置一个重复日期。然                                               
而，虽然思路简单，但你可以做到很多，用各种方法用于各种用途。与其去看一                                               
个长长的介绍，我觉得你可以去读读现有教程，有很多视频可以看，自己去体验                                               
一下 Org-mode 是多么强大。                                                                                           

** 6. Helm                                                                                                              
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
一些使用者喜欢它，但是其他人没有这么大的使用热情。我是后者的一部分。但                                               
在拥有这样一个庞大的追随者的情况下，是不能不提到它的。Helm 旨在完全变                                                
换你的 Emacs 使用体验。简单来说，Helm 是一个在 Emacs 中帮助你快速找到                                                
一个文件或命令的框架。根据你的输入，它将尝试使用词语自动完成来引导你将                                               
大脑的念头变为行动。起初感觉有点奇怪，但对一些人来说，Helm 本身就是一                                                
个信仰。虽然我不是 Helm 的粉丝，我欣赏 helm-occur 这一个伟大的工具可以                                               
在一个大文档搜索字符串并且在一个单独的缓冲区显示所有匹配结果，以便很容                                               
易在它们之间跳转。如果你正在寻找一个快速演示来了解 Helm 能做什么，我推                                               
荐这篇文章。                                                                                                         

** 7. ace-jump-mode                                                                                                     
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
这是另一个有一大群追随者的插件，我正在试图成为 ace-jump-mode 的粉丝。                                                
掌握这个插件，你会体验到超越鼠标感受。简单描述一下，通过你选择的快捷方                                               
式触发 ace-jump-mode 后，你会被提示输入字符。输入一个字符，所有以该字                                                
符开头的单词中的那个字符就会替换成一个唯一字符并被高亮。输入一个屏幕上                                               
的高亮字符，你的光标会直接跳转到高亮显示的那个词。我不得不承认，这让我                                               
使用它时有点反应不过来，但是，一旦你掌握它，它将显著提升你在一个文档里                                               
的移动速度。（LCTT 译注：用文字描述比较困难，如截图中，你输入的是一个                                                
“i”，然后屏幕中所有以“i”开头的单词中的那个“i”都被替换成了从 a 到 z 的                                                
字符，并高亮；你可以输入这些高亮的字符直接跳转到那个位置。）                                                         

** TODO [#C] 8. find-file-in-project                                                                                              
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
如果你喜欢 Sublime text 以及它可以用非常方便的Ctrl-p模糊搜索来打开一个                                               
项目中的任何文件的功能，你将会喜欢上 find-file-in-project （简称 ffip                                                
）的。使用设置指定了您的版本控制的根文件夹后，您可以轻松地调出一个很酷                                               
的文本条，通过快速扫描和搜索你的代码，来根据你输入的名称找到匹配的文件                                               
。我喜欢把它绑定到键盘上的 F6 键。如果你不知道整个目录从上到下的复杂结                                               
构，这很简单，而且非常易用。                                                                                         

** 9. Flymake                                                                                                           
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
对 IDE 的爱好者来说，我认为语法检查器是 IDE 最强大的特性之一，它非常适                                               
合初学者和方便了那些疲惫的程序员。感谢 Flymake，Emacs 用户也可以享受到                                               
了语法检查器。因为我工作中用 PHP 很多，Flymake 就不需要任何额外的配置                                                
。当我写代码的时候，它会自动检查我的代码和高亮任何一个包含问题的行。对                                               
于编译语言，Flymake 将寻找一个用于检查你的代码的 Makefile。真神奇。                                                  

** DONE 10. electric-pair                                                                                                    
CLOSED: [2018-12-19 三 21:18]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 21:18]
:END:      
                                                                                                                     
最后，但并非最不重要，在我看来，electric-pair 是最简单但最强大的插件之                                               
一。它会自动关闭你输入的括号。它起初看起来并不是很有用，但相信我，在被                                               
寻找配对括号折磨几百次之后，你会很高兴有这么一个插件，可以确保你所有的                                               
表达式的括号都是一一对应的。                                                                                         
                                                                                                                     
总结一下，Emacs 是一个奇妙的工具。这可不是一个令人惊讶的说法。试试这些                                               
插件，看着你的效率直线飙升吧。这个列表当然不是详尽的列表。如果你想贡献                                               
你的建议，请在评论中这样做。我自己一直在寻找新的插件来试着发现 Emacs                                                 
的新体验。                                                                                                           
                                                                                                                     
为Emacs配置newLISP开发环境                                                                                           

* emacs for programming

*** 跳转
[[https://www.cnblogs.com/elvalad/p/4069656.html][未检测教程一]]
*** Programming Emacs in Lisp and C
*** emacs for python
几篇链接:[[https://blog.csdn.net/mikelearnscode/article/details/23022277][一篇介绍了7个插件的文章]]

| 插件      | 详解功能                     | 调用 |
| Ipython   | 看上去是一个python的拓展版本 |      |
| company   | 补全                         |      |
| yasnippet | 一个模板软件                 |      |
| flymake   | 检测错误的                   |      |文档名发红即有错，下划线即错误          |
| flycheck  |                              |      |
| eglot     | 暂不好奇                         |      |

* 1 简介1
1.1 序

Org 是一个用文本方式来快速高效地做笔记、维持待办事项和做项目计划的模式。它是一个创作发布系统。

这个文档是 Org-mode 手册的一个压缩版本。包含了所有的基本功能和命令，以及一些重要的定制提示。本文档写给不想阅读200多页手册的新手。
1.2 安装

重要： 如果你用的是 Emacs 或者 XEmacs 包里的 Org 版本，请跳过本节，直接阅读 1.3 节。

如果你是从网站上下载的 Org 版本，无论是 zip 包还是 tar 文件或者是 Git 文件，最好在分发包目录里直接来设置它。把 lisp 子目录加到 Emacs 的加载路径里，可以把下面两句加在 “.emacs” 文件里：

(setq load-path (cons "~/path/to/orgdir/lisp" load-path))
(setq load-path (cons "~/path/to/orgdir/contrib/lisp" load-path))

为了提高速度可以用下面的 shell 命令将 Lisp 文件编译一下：

make

再把下面一行加到 .emacs 文件里。它可以使文件中的函数自动加载，而不是启动 Org 模式时立即加载。

(require 'org-install)

1.3 激活

把下面几行加到 .emacs 文件里。后三行是为命令定义全局快捷键――请改成适合你自己的。

;; The following lines are always needed. Choose your own keys.
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
(add-hook 'org-mode-hook 'turn-on-font-lock) ; not needed when global-font-lock-mode is on
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)

设置之后，打开 .org 扩展的文件会自动进入 org 模式。
1.4 反馈

如果你发现了问题，或者有问题评论或新想法，可以给Org的邮件列表 emacs-orgmode@gnu.org 发邮件。了解更多信息或者提交 bug，参见手册。

* 2 文档结构

Org是基于Outline模式的，它提供了更灵活的编辑结构文件的命令。
** 2.1 大纲

Org 是在大纲模式之上实现的。大纲模式可以让我们用层次结构来组织文档，这（至少对我来说）是
笔记和想法的最好实现方式。这种结构可以折叠（隐藏）文档的一部分而只显示文档的大概结构或
者只显示我们正在处理的部分。Org 大大简化了大纲模式的使用，它把
大纲模式的整个显示/隐藏功能整合到了一个命令中：org-cycle，这个命令绑定到了TAB键上。
** 2.2 标题

标题定义了大纲树的结构。它以处于一行左边缘的一个或多个星号开头。例如：

 * Top level headline
 ** Second level
 *** 3rd level
    some text
 *** 3rd level
    more text

 * Another top level headline

如果你不喜欢太多的星号，可以以空格后加一个星号作为标题的开头。查看 15.2 节 [Clean view]，那里有设置方法。
** 2.3 视图循环

大纲模式可以隐藏缓冲区里的部分正文。Org 用绑定到 TAB 和 S-TAB 上的两个全命令来改变视图。
TAB	子树循环：当加上一个前缀参数时（C-u TAB），在下面的状态中改变当前子树的视图
	FOLDED -> CHILDREN -> SUBTREE     
注释英文：折叠->孩子们 ->子树
	当加上shift键时会触发全局的视图循环。
	
S-TAB和C-u TAB	全局循环：使整个缓冲区在下列状态中循环
	OVERVIEW -> CONTENTS -> SHOWALL
C-u C-u C-u TAB	显示全部，包括drawers。

当 Emacs 刚打开文件时，全局的状态是 OVERVIEW，也即只有顶层的标题可见。这可以通过变量 org-startup-folded 来设置。也可以通过 startup 关键字设置只对单个文件有效：
总结：
TAB 单层的展开折叠
S-TAB  全局的逐层展开与折叠
C-u C-u C-u 展示全部

#+STARTUP: content

*** 2.4移动

下面的命令可以跳转到缓冲区其他的标题。
C-c C-n	下个标题  next
C-c C-p	上个标题  previous
C-c C-f	下个同级的标题  front
C-c C-b	上个同级的标题  back
C-c C-u	回到上层标题  

*** 2.5 结构编辑
M-RET	插入一个同级标题。如果光标在文本列表中，创建一个新的项（见 2.7 节 [Plain lists]）。如果处于一行的中间，这一行会被分开，后面的一部分成为新的标题。
M-S-RET	插入一个和当前标题同级的 TODO 项
TAB（新的空的条目中）	如果新的条目中还没有文字，TAB 会调整到合适的级别。
M-LEFT/RIGHT	将当前的标题提升/降低一个等级。
M-S-LEFT/RIGHT	将当前子提升/降低一个等级。
M-S-UP/DOWN	将子树上/下移（和前/后个子树交换）。
C-c C-w	将条目或区域传送到另一个文件中。见 9.2 节 [Refiling notes]。
C-x n s/w	将缓冲区视图局限到当前子树中/再次放宽视图

如果有活动区域（暂时标记状态），提升和降低功能将会对区域中的所有标题起作用。
*** 2.6 稀疏树

Org 模式的一个重要的功能是能根据大纲树中选择的信息构造出稀疏的树，这样文档就可以尽可能地折叠，但是选择的信息和它对应的标题会显示出来。试下就知道它是怎样工作的了。

Org 模式有几个命令可以创建这种树，这些命令都可以通过调度器来使用：
C-c /	它会提示再输入一个字符来选择稀疏树的创建命令。
C-c / r	触发后，会提示输入匹配串，并且将所有匹配的项显示成稀疏树。所有的匹配项都会高亮显示；按 C-c C-c 取消高亮。

其他的基于 TODO 关键字、标签或属性来选择标题的稀疏树命令，我们会在本手册的后面讨论。
*** 2.7 文本列表

在大纲树的一项中，自定义格式的列表可以提供更多的组织结构，也使我们可以得到一个复先框列表（见 5.6 节［复先框］）。Org 模式可以处理这种列表，并且 HTML 导出器（见12章）也支持这种格式。

Org 能够识别有序列表、无序列表和描述列表。

    无序列表项以‘-’、‘+’或者‘*‘开头。
    有序列表项以‘1.’、‘1)’或者开头。
    描述列表用‘::’将项和描述分开。

同一列表中的项的第一行必须缩进相同程度。当下一行的缩进与列表项的的开头的符号或者数字相同或者更小时，这一项就结束了。当所有的项都关上时，或者后面有两个空行时，列表就结束了。例如：

 ** Lord of the Rings
   My favorite scenes are (in this order)
   1. The attack of the Rohirrim
   2. Eowyn's fight with the witch king
       + this was already my favorite scene in the book
       + I really like Miranda Otto.
   Important actors in this film are:
   - Elijah Wood :: He plays Frodo
   - Sean Austin :: He plays Sam, Frodo's friend.
*** ??
当光标位于一项的第一行时（带有项标志符号的行），下面的命令将会作用于该项：
TAB	折叠项
M-RET	在当前级别插入一个项，有前缀时是强制新建一个标题
M-S-RET	插入一个带有复先框的项（见 2.5 节［复先框］）
M-S-UP/DOWN	将当前项和它的子项向上/下移动（和相同的缩进的前/后一个项交换位置）。如果列表是有序的，数字会自动改变
M-LEFT/M-RIGHT	提升/降低项的缩进，不包含子项
M-S-LEFT/RIGHT	提升/降低项的缩进，包含子项
C-c C-c	如果项中有复先框，就触发改变其状态。并且自动保持本项的符号与缩进在列表中的一致性
C-c -	循环改变将当前列表的项标志符号
*** 脚注

脚注就是以脚注定义符号开头的一段话，脚注定义符号是将脚注名称放在一个方括号里形成的，要求放在第0列，不能有缩进。而引用就是在正文中将脚注名称用方括号括起来。例如：

The Org homepage[fn:1] now looks a lot better than it used to.
...
[fn:1] The link is: http://orgmode.org

用下面的命令来处理脚注：
C-c C-x f	这是一个移动命令。当光标处理引用处时，跳转到它的定义；当光标处理定义处时，跳转到第一个引用处。其他情况下，新建一个脚注。当有前缀时，会提供一个菜单供选择操作，其中包括重新给脚注编号。
C-c C-c	在定义和引用之间跳转

扩展阅读：
手册第 2 章
Sacha Chua's tutorial
* 3 表格

Org 提供了快速易用的表格编辑功能。通过调用 Emacs 内嵌的 ‘calc’包（对于 Emacs 的计算器可以查看 Emacs Calculator 手册）它支持类似于制表软件的计算操作。

Org 能够很容易地处理 ASCII 文本表格。任何以‘|’为首个非空字符的行都会被认为是表格的一部分。’|‘也是列分隔符。一个表格是下面的样子：

| Name  | Phone | Age |
|-------+------+-----|
| Peter | 1234 | 17  |
| Anna  | 4321 | 25  |

当你在表格内部输入 TAB、RET 或者 C-c C-c 时表格都会自动调整。TAB 会进入下一个区域（RET 进入下一行）并且创建一个新的行。表格的缩进程度可以在第一行设定。以’|-’开头的一行会作为一个水平分隔行，当它下次调整排列时会将‘-’扩展至填充整行。所以想要建上面的那个表格，只需键入：

|Name|Phone|Age|
|-

然后 TAB 排列表格。还有一个更快的方法就是键入|Name|Phone|Age，再 C-c RET。

在表格区域中输入文本时，DEL、BACKSPACE 和所有其他的字符会以特殊的方式处理，防止影响到其他的区域。当按 TAB、S-TAB 或者 RET 将光标移动到其他区域时，区域中会自动填充一些空格。
*** 创建和转换

C-c | 将活动区域（选中区域）转换成一个表。如果第一行至少有一个 TAB 字符，就用 TAB 划分内容；如果第一行都有逗号，就分逗号划分内容；否则就用空白符来划分区域。如果当前没有活动区域就会建立一个空的 Org 表格。其实用|Name|Phone|Age C-c RET 来建表会更简单一点。
*** 调整和区域移动
C-c C-c	调整表格，不移动光标
TAB	调整表格，将光标移到下一个区域，必要时新建一行
S-TAB	调整表格，将光标移到上一个区域
RET	调整表格，将光标移到下一行，必要时会新建一行
*** 编辑行和列
M-LEFT/RIGHT	左/右移当前列
M-S-LEFT	删除当前行
M-S-RIGHT	在光标位置左边添加一列
M-UP/DOWN	上/下移当前行
M-S-UP	删除当前行
M-S-DOWN	在当前行上面添加一行。如果有前缀，则在下面添加一行
C-c -	在当前行下面添加一个水平线。如果带前缀，则在上面添加一行水平线
C-c RET	在当前行下面添加一个水平线。并将光标移动到下一行
C-c ^	将表排序。当前位置所在的列作为排序的依据。排序在距当前位置最近的两个水平线之间的行（或者整个表）中进行

扩展阅读：
手册第 3 章
Bastien’s table tutorial
Bastien’s spreadsheet tutorial
Eric’s plotting tutoria
*** 计算
可以初步参考[[https://blog.csdn.net/csfreebird/article/details/45459465][博客 ]]进行学习
|          |    |
|----------+----|
|          | 30 |
|      |  6 |
|      | -5 |
|          |    |
|          |    |

* 4 超链接

就像 HTML 一样，Org 也提供了文件的内部链接，以及到其他文件、新闻组、电子邮件的外部链接等链接格式。
4.1 链接格式

Org 能够识别 URL 格式的文本并将它们处理成可点击的链接。通常链接格式是这样的：

[[link][description]]  或者  [[link]]

链接输入一旦完成（所有的括号都匹配），Org 就会改变它的视图。这里会看到 ”description“ 和 ”link“ ，而不是

[[link][descriptoin]]

和

[[link]]。

要想编辑链接，可以光标置于链接上并键入 C-c C-l。
*** 4.2 文件内部链接

如果一个链接地址并不是 URL 的形式，就会作为当前文件内部链接来处理。最重要的一个例子是

[[#my-custom-id]]


它会链接到 CUSTOM_ID 属性是 “my-custom-id” 的项。

类似

[[My Target]]

和

[[My Target][Find my target]]

的链接，点击后本文件中查找对应的目标 “<<My Target>>” 。
*** 4.3 外部链接

Org 支持的链接格式包括文件、网页、新闻组、BBDB 数据库项、IRC 会话和记录。外部链接是 URL 格式的定位器。以识别符开头，后面跟着一个冒号，冒号后面不能有空格。下面是一些例子：

http://www.astro.uva.nl/~dominik            on the web
file:/home/dominik/images/jupiter.jpg       file, absolute path
/home/dominik/images/jupiter.jpg            same as above
file:papers/last.pdf                        file, relative path
file:projects.org                           another Org file
docview:papers/last.pdf::NNN                open file in doc-view mode at page NNN
id:B7423F4D-2E8A-471B-8810-C40F074717E9     Link to heading by ID
news:comp.emacs                             Usenet link
mailto:adent@galaxy.net                     Mail link
vm:folder                                   VM folder link
vm:folder#id                                VM message link
wl:folder#id                                WANDERLUST message link
mhe:folder#id                               MH-E message link
rmail:folder#id                             RMAIL message link
gnus:group#id                               Gnus article link
bbdb:R.*Stallman                            BBDB link (with regexp)
irc:/irc.com/#emacs/bob                     IRC link
info:org:External%20links                   Info node link (with encoded space)

链接的括号应当是闭合的。当链接含有描述文字是显示描述文字而不是链接地址（见 4.1 节［链接格式］），例如：

[[http:www.gnu.org/software/emacs/][GNU Emacs]]

如果描述信息是一个文件名或者是指向图片的 URL。HTML 导出（见 12.4 节[HTML 导出]）时会将图片内联成一个可以点击的按钮。如果没有描述信息且链接指向一个图片，那么图片就会嵌入到导出的 HTML 文件中。
*** 4.4 使用链接

Org 提供了以下方法来创建和使用链接。
C-c l	在当前位置保存一个链接。这是一个全局命令（你可以设置自己的快捷键），可以在任何类型的缓冲区中使用。链接保存下来以便以后插入 Org 文件中（见下面）
C-c C-l	插入一个链接。它会让你输入，你可以输入一个链接，也可心用上/下键来获取保存的链接。它还会让你输入描述信息。
C-c C-l（光标在链接上）	当光标处于链接上时，你可以修改链接
C-c C-o 或者 mouse-1 或者 mouse-2	打开链接
C-c &	跳回到一个已记录的地址。用 C-c % 可以将地址记录下来，内部链接后面的命令也会自动将地址记录下来。使用这个命令多次可以一直往前定位。
4.5 目标链接

文件链接可以包含一些其他信息使得进入链接时可以到达特定的位置。比如双冒号之后的一个行号或者搜索选项。

下面是一些包含搜索定位功能的链接例子以及其说明：

file:~/code/main.c::255                     进入到 255 行
file:~/xx.org::My Target                    找到目标‘<<My Target>>’
file:~/xx.org/::#my-custom-id               查找自定义 id 的项

扩展阅读：
手册第四章
* 7 属性

属性是一些与条目关联的键值对。它们位于一个名为 PROPERTIES 的特殊抽屉中。第一个属性都单独一行，键在前（被冒号包围），值在后：

 * CD collection
 ** Classic
 *** Goldberg Variations
    :PROPERTIES:
    :Title:    Goldberg Variations
    :Composer: J.S. Bach
    :Publisher: Deutsche Grammophon
    :NDisks:   1
    :END:

通过设置属性 “:Xyz_ALL:” ，你可以为属性 “:Xyz:” 设置所有合法的值。这个特定的属性是有 继承性 的，即，如果你是在第 1 级别设置的，那么会被应用于整个树。当合法的值设定之后，设置对应的属性就很容易了，并且不容易出现打字错误。用CD唱片集为例，我们可以预定义发行商和盒中的光盘数目：

 * CD collection
  :PROPERTIES:
  :NDisks_ALL: 1 2 3 4
  :Publisher_ALL: "Deutsche Grammophon" Philips EMI
  :END:

也可以在全局设置 org-global-properties ，或者在文件级别设置：

#+PROPERTY: NDisks_ALL 1 2 3 4

C-c C-x p	设置一个属性。会询问属性名和属性值。
C-c C-c d	从当前项中删除一个属性。

要基于选择的属性创建稀疏树或者特殊列表，跟标签搜索的命令相同（见第6.3节）。搜索字符串的语法在第10.3.3节中详述。
7.1 扩展阅读

手册第7章
Bastien Guerry’s column view tutorial
* 6 标签

要为交叉相关的信息提供标签和上下文，一个不错的方法是给标题分配标签。Org 模式能够广泛地支持标签。

每一个标题都能包含多个标签，它们位于标题的后面。标签可以包含字母，数字， ‘_’ 和 ‘@’ 。标签的前面和后面都应该有一个冒号，例如，“:work:”。可以指定多个标签，就像“:work:urgent:”。标签默认是粗体，并和标题具有相同的颜色。

*** 6.1 标签继承

标签具有大纲树的继承结构。如果一个标题具有某个标签，它的所有子标题也会继承这个标签。例如，在列表

 * Meeting with the French group                                        :work:
 ** Summary by Frank                 :boss:notes:
 *** TODO Prepare slides for him     :action:

中,尽管没有明确标出,最后一个标题会有标签“:work:”，“:boss:”，“:note:”，和“:action”。你也可以设定一个标签让所有的标题都继承，就好像标签在包含整个文件的第零级标题中指定了一样。用下面的方法5：
#+BEGIN_SRC 
 例如：#+FILETAGS: :Peter:Boss:Secret:
#+END_SRC

这里应该是一个全页面的tag
*** 6.2 设置标签

在标题后可以很容易地输入标签。在冒号之后，M-TAB 可以补全标签。也有一些专门的命令用于输入标签：
C-c C-q	为当前标题输入标签。Org 模式既支持补全，也支持单键接口来设置标签，见下文。回车之后，标签会被插入，并放到第 org-tags-column 列。如果用前缀 C-u，会把当前缓冲区中的所有标签都对齐到那一列，这看起来很酷。
C-c C-c	当光标处于标题上时，这个命令同C-c C-q。

Org 支持基于一个标签列表来插入标签。默认情况这个列表是动态构建的，包含了当前缓冲区中使用过的所有标签。你也可以通过变量 org-tag-alist 在全局设定一个标签的硬列表（hard list）。另外，对于某个特定文件你也可以用下面这几行设置一个默认列表：

#+TAGS: @work @home @tennisclub
#+TAGS: laptop car pc sailboat

默认 Org 模式用一个迷你缓冲区补全设施来输入标签。另外，它也实现了一个更快速，称为 快速标签选择 （ fast tag selection ）的标签选择方法。这使得你只用按一次键就可以选择或者取消一个标签。为了使它能很好地工作，需要为常用的标签赋唯一的值。你可以在你的“.emacs”文件中通过设置变量 org-tag-alist 作全局设定。例如，如果你需要在不同的文件中经常要给条目添加标签“:@home:”，这时你就可以像这样设置：

(setq org-tag-alist '(("@work" . ?w) ("@home" . ?h) ("laptop" . ?l)))

如果标签只用于当前正在处理的文件，那么你可以这样设置标签选项行：

#+TAGS: @work(w) @home(h) @tennisclub(t) laptop(l) pc(p)
*** 6.3 标签查找

一旦标签体系设置好，就可以用来收集相关联的信息到指定列表中。
*注意* 此时标题应是完整的
C-c \      将含匹配标签的标题处（****）置黑	并构造稀疏树 
C-c / m	用匹配标签搜索的所有标题构造一个稀疏树。带前缀参数C-u时，忽略所有还是TODO行的标题。
C-c a m	用所有议程文件匹配的标签构造一个全局列表。见第 10.3.3 节。
C-c a M	用所有议程文件匹配的标签构造一个全局列表，但只搜索 TODO 项，并强制搜索所有子项（见变量 org-tags-match-listsublevels）。

这些命令构成的标签树复制时候，会连带这复制不带标签的部分，并不是说内容变了，只是题目展示的方式变了
这些命令都会提示输入字符串，字符串支持基本的逻辑去处。像“+boss+urgent-project1”，是搜索所有的包含标签“boss”和“urgent”但不含“project1”的项；而 “Kathy|Sally”，搜索标签包含“Kathy”或者“Sally”和项。搜索字符串的语法很丰富，支持查找TODO关键字、条目级别和属性。更详细的介绍和例子，见第 10.3.3 节。

扩展阅读
手册第 6 章
Sacha Chua’s article about tagging in Org-mode
* 5 待办事项TDOD GTD

Org 模式并不用一个单独的文件来维持 TODO 列表2。它是一些笔记的集合体，因为 TODO 列表是在你记录笔记的过程中逐渐形成的。你 Org 模式下可以很容易地将树中的一项标记为一个 TODO 的项。用这种方式，信息内容不会冗余加倍，而且可以显示 TODO 项的上下文环境。

当然，这种处理待办事项的方式会将它们分散于各个笔记文件中。Org 模式提供了一些方法使我们可以把它们看作一个整体来处理。
*** 5.1 使用TODO状态                                                         

当标题以 TODO 开关时它就成为了一个 TODO 项，例如：

***TODO Write letter to Sam Fortune
下面是一些使用 TODO 项的常用命令：
C-c C-t	将当前项的状态在（unmarked）->TODO->DONE 之间循环切换，同样的切换也可以在时间轴（timeline） 和议程（ agenda） 的缓冲区（buffer）中用 t 键“远程”进行。（见 2.6 节[稀疏树]）

C-c / t	在稀疏树中显示 TODO 项。将 buffer 折叠，但是会显示 TODO 项和它们所在的层次的标题。
C-c a t	显示全局 TODO 列表。从所有的议程文件中收集 TODO 项到一个缓冲区中。此处显示为空，不知？详见 10.3.2 节。
S-M-RET	在当前项下插入一个新的 TODO 项。
shift-left/right 调整优先级
改变 TODO 的状态会触发标签改变。查看选项 org-todo-state-tags-triggers 的描述获得更多信息。
*** 5.2 多状态工作流程

你可以用 TODO 关键字来定义不同的状态，用以处理项，比如：

(setq org-todo-keywords
      '((sequence "TODO" "FEEDBACK" "VERIFY" "|" "DONE" "DELEGATED")))

竖直线将 TODO 关键字（还需要进一步的动作）和 DONE 状态（不需要进一步的动作）分隔开。如果你不给出竖直线，最后一个状态会作为 DONE 状态。设置之后，C-c C-t 就会将状态从 TODO 转换到 FEEDBACK，再转换到 VERIFY，最后到 DONE 和 DELEGATED。

有时你可能希望同时使用几个不同的 TODO 状态集合。例如，你可能想要一个基本的 TODO/DONE，以及一个修改 bug 的工作流程和一个隔开的状态来表示取消的项目（既还是 DONE，也不需要进一步的动作），你可以这样设置：

(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)")
        (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)")
        (sequence "|" "CANCELED(c)")))

关键字应该各不相同，这样对于一个选项 Org 才知道该用哪个状态序列（集合）。例子中也给出了快速使用一个关键字的方法，就是在关键字后面括号中给出快捷字母——当用 C-c C-t时，会询问，让你输入一个字母。

要定义只在一个文件中有效的 TODO 关键字，可以在文件中任意地方给出下面的文本：

#+TODO: TODO(t) | DONE(d)
#+TODO: REPORT(r) BUG(b) KNOWNCAUSE(k) | FIXED(f)
#+TODO: | CANCELED(c)

当改变这些行中的一行后，光标停留在改变行上，用 C-c C-c 让改变生效。
*** 5.3 进度日志

当你改变一个 TODO 状态为 DONE 时，或者当你每次改变一个 TODO 项的状态时，Org 都会自动记录时间戳或者作一个记录。这是高度可配置的。可以基于每一个关键字进入设置，并且可以定位到一个文件甚至子树。怎样记录一个任务的工作时间，见 8.4 节。

完成的项目

最基本的日志功能是跟踪一个特定项目的完成。这可以这样实现：3

(setq org-log-done 'time)

这时当你将一个项目从一个 TODO（未完成）状态改变为一个完成状态时，标题下面就会插入一行 “CLOSED:[timestamp]”。如果你想和时间戳一起作一个记录，用：4

(setq org-log-done 'note)

这时会提示你输入一个记录（note），并将它保存在标题为“Closing Note”项目之下。

跟踪TODO状态变化

你可能想跟踪 TODO 状态的变化。可以只记录一个时间戳，也可以为变化作一个带时间戳的记录。记录会被插入到标题之后形成列表。当有很多记录之后，你可能希望将记录取出放到抽屉里。通过定制变量 org-log-into-drawer 可以实现这个功能。 对于状态记录，Org 可以实现基于每个状态关键字的设置。实现方法是在每个后的括号中指定“！”（记录时间戳）或“@”（作一个记录）。例如：

#+TODO: TODO(t) WAIT(w@/!) | DONE(d!) CANCELED(c@)

将会设置 TODO 关键字和快速访问字母，以及当一个项目设为 DONE 时，会记录时间戳，当状态变为 WAIT 或 CANCELED 时，会作一个记录。这个语法也适用于变量 org-todo-keywords。
5.4 优先级

如果你广泛地使用 Org 模式，这样你就会有大量的 TODO 项。给它们设定优先级就很有必要。可以在 TODO 项的标题中加入一些标记（cookie）来设置它们的优先级，像这样：

 *** TODO [#A] Write letter to Sam Fortune

Org模式支持三个优先级别：’A‘、’B‘和’C‘。’A‘是最高级别，如不指定，’B‘是默认的。优先级只在议程中有用。
C-c ,	设置当前标题的优先级。按’‘’‘’‘选择一个级别，或者SPC删除标记（cookie）。
S-UP	
S-Down	增加/减少当前标题的优先级。
*** 5.5 任务细分[/]

很多时候将一个大的任务分成几个的易于完成的小任务是明智的。你可以通过在TODO项目下新建一个大纲树，并在子树上标记子任务来实现这个功能。为了能对已经完成的任务有个大致的了解，你可以在标题的任何地方插入‘[/]’或者‘[%]’。当每个子任务的状态变化时，或者当你在标记上按 C-c C-c时，这些标记状态也会随之更新。例如：

 * Organize Party [33%]
 ** TODO Call people [1/2]
 ** TODO Peter
 *** DONE Sarah
 **  TODO Buy food
 **  DONE Talk to neighbor
*** 5.6 复选框
ss
当纯文本中的项以‘[]’开头时，就会变成一个复选框。复选框不会包含在全局 TODO 列表中，所以它们很适合地将一个任务划分成几个简单的步骤。下面是一个复选框的例子：

 * TODO Organize party [1/3]
   - [-] call people [1/2]
     - [ ] Peter
     - [X] Sarah
   - [X] order food
   - [ ] think about what music to play

复选框是分层工作的。所以如果一个复选框项目如果还有子复选框，触发子复选框将会使该复选框变化以反映出一个、多个还是没有子复选框被选中。

下面是处理复选框的命令：
C-c C-c	触发复选框的状态或者（加上前缀）触发复选框的的存在状态。
M-S-RET	增加一个带有复选框的项。这只在光标处于纯文本列表项（见 2.7 节）中才起使用。

扩展阅读：
手册第5章
David O’Toole’s introductory tutorial
Charles Cave’s GTD setup
*** 推荐任务管理办法。
使用标签：
| t1y | tjan | t1w | t1d | t1h | t5m |
* 8 日期和时间

为了支持工程的计划，TODO 项可以标记上日期和/或时间。带有日期和时间信息的特定格式的字符串在 Org 模式中称为时间戳。
*** DONE testtime 
CLOSED: [2019-01-06 日 15:44] SCHEDULED: <2019-01-03 四>
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-01-06 日 15:44]
:END:      
*** DONE 学习emacstodo
CLOSED: [2019-01-06 日 15:41]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-01-06 日 15:41]
:END:      
时间表的问题

*** 8.1 时间戳


时间戳是一个具有特定格式的日期（可能带有时间和时间段）说明，例如 ~ 2005-10-01~ Tue ， ~ 2003-09-16~ Tue 09:39 ，或者 ~ 2003-09-16~ Tue 12:00-12:30 。 时间戳可以出现在树条目的标题和正文的任何地方。它能使条目只在特定的日期才出现在议程列表中。（见第 10.3.1 节）我们区分为：

普通时间戳；事件；约会
***** 简单时间戳 标准形式 
一个简单的时间戳只是给一个条目加上时间和日期。这跟在纸质的议程上写下约会和事件是一样的。

 * Meet Peter at the movies <2006-11-01 Wed 19:15>
 * Discussion on climate change <2006-11-02 Thu 20:00-22:00>
con
***** 具有时间间隔的时间戳(按照时间间隔进行重复)

一个时间戳可以包含一个时间间隔，表示事件不只在指定的时间发生，还在每隔一个特定的时间如 N 天（d）、周（w）、月（m）或者年（y）之后重复发生。下面的事件每周二在议程中显示：

 * Pick up Sam at school <2007-05-16 Wed 12:30 +1w>
 con

注意循环的格式，只有当格式正确时候，循环才能奏效
#+BEGIN_SRC 
<2006-11-01 Wed 19:15 +1d>
应当插入到仅仅相隔一行的位置
#+END_SRC

如前面 habits 设置周期性代办事项 中所示， .+2d/4d 意味着

    周期至少为2天，至多为4天
    当任务标记为结束时，重新从 今天 开始记

描述时间周期的符号有三种

    +
    这个要求必须每次的任务都完成，如果落下，需要补上。比如说交房租
    .+
    之前未完成的可以忽略，当标记为结束时，从 今天 开始
    ++
    同 .+, 但当标记为结束时，从下个周期开始。比如前面那个例子下个任务会从２天后开始
--------------------- 
作者：skuldjf 
来源：CSDN 
原文：https://blog.csdn.net/skuldjf/article/details/78068111 
版权声明：本文为博主原创文章，转载请附上博文链接！
******* TODO 查询更多的时间戳内容，以实现自己需要的功能g
***** 时间/日期段 --

两个时间戳用‘–’连接起来就定义了一个时间段：

 ** Meeting in Amsterdam
   <2004-08-23 Mon>--<2004-08-26 Thu>
***** 日记样式的 sexp 条目

为了能定义更复杂的时间，Org 模式支持 Emacs 日历/日记包（calendar/diary package）中的日记条目。例如：

 * The nerd meeting on every 2nd Thursday of the month
   <%%(diary-float t 4 2)>
***** 非激活的时间戳

跟普通时间戳一样，但是这里是方括号而不是尖括号。这种时间戳是未激活的，它 不 会让一个条目显示在议程中。

 * Gillian comes late for the fifth time [2006-11-01 Wed]
con
***** TODO 复合时间戳实验
基本实现我需要的全部功能
*** 8.2 创建时间戳
时间戳要有特定的格式，这样才能被Org模式识别。下面的命令可以用来正确地处理时间戳的格式。
C-c .	询问日期并输入正确的时间戳。当光标处理一个时间戳之上时，是修改这个时间戳，而不是插入一个新的。如果这个命令连用再次，就会插入一个时间段。加上前缀c-u会附带当前时间。
C-c !	功能同C-c .，但是插入的是一个未激活的时间戳。目前不能使用，被老哥给屏蔽了，建议
    1. 到一个新emacs上寻找方法名 然后类推
    2. 其他
S-LEFT/RIGHT	将光标处理的时间戳改变一天。
S-UP/DOWN	改变时间戳中光标下的项。光标可以处在年、月、日、时或者分之上。当时间戳包含一个时间段时，如 “15:30-16:30”，修改第一个时间，会自动同时修改第二个时间，以保持时间段长度不变。想修改时间段长度，可以修改第二个时间。

当 Org 模式询问时间/日期时，能接收任何包含时间和/或日期的字符串，它能根据当前的时间日期智能地分析字符串，从而得到没有指明的信息。你也可以用弹出的日历中选择日期。想完整地了解时间/日期询问的工作方式，可以参考手册。
***** test
*** 8.3 截止期限和计划安排

时间戳前面可以加一些关键字来协助计划安排。
***** 截止期限 c-c c-d 

意义：任务（大多数情况都会是一个TODO项，当然也可以不是）应该完成的日期。
C-c C-d	在标题下面一行插入一个带有“DEADLINE”关键字的时间戳。
vv
在 截止日期 ， 任务 会列在 议程 中。另外， 今天的议程 会在任务到期 orgdeadline-warning-days 天前对即将即将到期以及已经过期的任务给出提醒，直到任务被标记为 DONE。例如：

 *** TODO write article about the Earth for the Guide
    The editor in charge is bbdb:Ford Prefect
    DEADLINE: <2004-02-29 Sun>
***** 日程安排 c-c c-s 将计划安排到指定日期

意义：你计划在给定的那个日期开始进行那项任务。6
C-c C-s	在标题下面插入一个带有“SCHEDULED”关键字的时间戳。

在给定的日期标题会列在议程中。7另外，对于过期的日程安排会在编辑为 今天 并给出提醒，直到被标记为 DONE。也就是说，任务会自动推迟日期直到它被完成。

 *** TODO Call Trillian for a date on New Years Eve.
    SCHEDULED: <2004-12-25 Sat>

有些任务需要一再重复出现。Org 模式在截止期限、计划安排和普通时间戳中用所谓的中继器来管理这种任务。在下面的例子中：

 ** TODO Pay the rent
DEADLINE: <2005-10-01 Sat +1m>

+1m 是一个中继器；上面的意思是任务有一个截止期限 ~ 2005-10-01~ ，并从这个日期开始每月都重复出现。
*** 8.4 记录工作时间

使用 Org 可以记录在一个工程中花在某些特定任务上的时间。
C-c C-x C-i	开始当前条目的计时（clock-in）。这会插入一个 CLOCK 关键字和一个时间戳。加上 C-u 前缀，从当前已经计时的任务中选择任务。
C-c C-x C-o	停止计时（clock-out）。这会在开始计时的地方插入另一个时间戳。它会直接计算使用时间并插入到时间段的后面如 “=> HH:MM”。
C-c C-x C-e	为当前的计时任务更新进度。
C-c C-x C-x	取消当前的计时。当你误操作打开一个计时时，或者转而去做其他事情时，这个命令就很有用。
C-c C-x C-j	跳转到包含当前正在运行的计时的任务条目。用 C-uf前缀从当前计时的任务中选择。
C-c C-x C-r	在当前文件插入一个包含像 Org 表格一样的计时报告的动态块。当光标正处于一个存在的块上时，更新它。
	#+BEGIN: clocktable :maxlevel 2 :emphasize nil :scope file
	#+END: clocktable
	如何定制视图，见手册。
C-c C-c	在一个已经存在的计时表格之上时，更新它。 更新动态块。光标需要置于动态块 #+BEGIN 这行。

l 键可能会在时间轴（见第 10.3.4 节）和议程（见第 10.3.1 节）中使用来查看一天中处理和关闭了哪些任务。

扩展阅读
手册第 8 章
Charles Cave’s Date and Time tutorial
Bernt Hansen’s clocking workflow
*** 时间戳格式修改
见夸克标签
con

* 9 捕获——转发——存档

任何组织系统都有一个重要功能，就是能捕获新的灵感或者任务，并将相关的引用材料与之联系起来。Org 提供了一个捕获过程来创建任务。它将与一个任务相关的文件（附件）保存在一个特定的目录下。在系统中，任务和项目经常移动。将整个项目树保存到一个归档文件中可以保持系统简洁快速。

*** 9.1 捕获

Org 的获取一个新条目的方法很大程序上受 John Wiegley 的 excellent remem-ber package 的影响。它使得你可以在工作流程中中断一小会儿来存贮一个简短的笔记。Org可以为新条目定义模板，并将它们与不同的目标文件关联起来以保存笔记。


设定截取位置8
shiii
下面的定制为笔记设置了一个默认的目标9文件，并为捕获新的任务定义了一个全局快捷键10。

(setq org-default-notes-file (concat org-directory "/notes.org"))
(define-key global-map "\C-cc" 'org-capture)

截取的使用
C-c c	启动一个捕获过程。进入一个窄的间接缓冲区来编辑条目。
C-c C-c	一旦完成捕获信息的输入，可以用 C-c C-c 返回之前的窗口，继续中断的工作。
C-c C-w	将条目保存到一个接收地址（见第2节）并结束。
C-c C-k	取消捕获过程，返回之前的状态。

捕获模板

用可以用不同的模板来做不同的捕获笔记，并将它们保存到不同的地方。例如，你想将新任务保存到文件“TODO.org”的“Tasks”标题下，而将日记项目保存到“journal.org”中一个时间树中。你可以：

 (setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
         "* TODO %?\n %i\n %a")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
         "* %?\nEntered on %U\n %i\n %a")))

其中，第一个字符串是模式的关键字，第二个字符串是简短的描述信息。接着是条目的类型和保存笔记的目标地址。最后是模板本身，它利用%作转义符基于时间和上下文来填充一些信息。

当你调用 M-x org-capture 时，Org 提示输入一个键来选择模板（如果你有多个模板），然后就会给出像这样的内容：

 * TODO
 [[file:link to where you were when initiating capture]]

在扩展模板时，可以用%转义符进行动态地插入内容。下面是一些可以使用的项，查看手册获得更多的选项。11
%a	注解，通常是由 org-store-link 创建的链接
%i	初始化内容，当记忆时区域被C-u调用
%t	时间戳，只是日期
%T	带有日期和时间的时间戳
%u，%U	同上，但是时间戳不激活
*** 9.2 转送笔记

当你回顾捕获的数据时，可以想把其中的一些条目转送到另一列表中，比如说到一工程项目。剪切，查找正确的地址，然后再粘贴笔记，这就似乎有些麻烦。为了简化这个过程，可以用专门的命令：
C-c C-w	转送光标处的条目或者区域。这个命令会提供一些目标地址供选择,你可以通过补全功能选择一个。条目（或者区域中的所有条目）就会作为一个子项填充到目标标题下。转送的目的地应包含在议程文件中
	默认情况下，当前缓冲区的一级标题会被作为转送的目标，你可以通过设置给出跨多个文件的复杂的定义。详见变量 org-refile-targets 的描述。
C-u C-c C-w	借助于转送功能的接口来跳转到一个标题。
C-u C-u C-c C-w	跳转到 org-refile 最后转送子树所到的地方。
*** 9.3 归档

当一个用（子）树表示的工程完成后，你可能想把它移走，不让它再在议程里显示。归档能使你的工作文件变得简洁，并能使议程视图构造等全局搜索保持高效。最常用的归档命令是将工程树移到另一个文件——归档文件。
C-c C-x C-a	用变量 orgarchive-default-command 指定的命令归档当前的项。
                  当前项直接就关闭了，，不能打开了。
                  个人使用：最好是先将内容整理出来再归档，不然会很麻烦
C-c C-x C-s 或者简化为 C-c $	将光标处的子树归档至 org-archive-location 指定的位置。

默认的归档位置是当前文件同目录下，名为当前文件名后加 “_archive” 的文件。例子和设置位置的方法见变量 org-archivelocation 的帮助信息。下面是一个在缓冲区内设置该变量的方法：

#+ARCHIVE: %s_done::
*** 扩展阅读
手册第9章
Charles Cave’s remember tutorial
Sebastian Rose’s tutorial for capturing from a web browser
* 10 议程视图
根据 Org 的工作方式，TODO 项、时间戳和带标签的标题分散在一个或者多个文件中。为了能够查看某一天的项目或者事件，信息必须收集在一起，以一种的有条理方式排序、显示。有几种不同的视图，见下文。

收集的信息在一个专门的议程缓冲区中显示。这个缓冲区是只读的，但是提供了一些命令可以访问原 Org 文件中对应的条目，并且可以远程地编辑这些文件。从议程缓冲区中远程编辑是说，比如，你可以在议程缓冲区中改变标题和约会的日期。议程缓冲区中使用的命令在第 10.4 节列出。
*** 10.1 议程文件

显示的信息通常是从各个议程文件中收集来的，这样文件在变量 org-agenda-files 中列出。
C-c [	将当前文件加入到议程文件列表中。当前文件会被加到列表的前面。如果文件已经在列表中，会被移到前面。带有前缀时，文件添加/移到到后面。
C-c ]	将当前文件从议程文件列表中删除。
C-,	遍历议程文件列表，依次访问其中的每一个文件。
*** 10.2 议程调度器

视图是通过议程调试器创建的，通常我们会给它设置一个全局快捷键——比如 C-c a （见第1.2节）。按 C-c a 之后，就会提示再输入一个字母来执行对应的命令：
a	日历式的议程。（见 10.3.1）
t/T	TODO 项的列表。（见 10.3.2节）
m/M	匹配某个标签表达式的标题的列表。（见 10.3.3）
L	当前文件的时间轴视图。（见 10.3.4）
s	通过关键字和/或正则表达式选中的条目的列表。
*** 10.3 内建议程视图
***** 10.3.1 周/日议程

周/日议程就像纸质的议程一样，用以显示本周或当天的所有任务。
C-c a a	从一列 Org 文件中为本周收集出一个议程。议程显示出每天的条目。

Emacs 包含了 Edward M. Reingold 的日历和日记功能。Org 模式能识别日记的语法并允许在 Org 文件中直接使用日记的 sexp 条目：12

 * Birthdays and similar stuff
#+CATEGORY: Holiday
  %%(org-calendar-holiday) ; special function for holiday names
#+CATEGORY: Ann
  %%(diary-anniversary 5 14 1956) Arthur Dent is %d years old
  %%(diary-anniversary 10 2 1869) Mahatma Gandhi would be %d years old

Org 可以跟 Emacs 的约会提醒功能结合。想添加议程文件中的约会提醒，可以使用命令 org-agenda-to-appt。详见帮助文档的描述。
******* TODO Edward M. Reingold 的日历和日记功能
******* TODO 提醒功能
***** 10.3.2 全局TODO列表

全局TODO列表将所有未完成的 TODO 项格式化并集中到一处。TODO 项的远程编辑使得我们只用按一下键就可以改变 TODO 项的状态。TODO 列表中可以使用的命令在第10.4节给出。
C-c a t	显示全局 TODO 列表。这会从所有的议程文件（见第10章）中收集 TODO 项到一个缓冲区中。
C-c a T	同上，但可以选择 TODO 关键字
***** 10.3.3 匹配标签和属性

如果议程文件中的标题带有标签（见第6章）或者带有属性（见第7章），就可以基于这些元数据筛选标题到议程缓冲区中。这里描述的匹配语法在用 C-c / m 创建稀疏树时也同样适用。在标签列表中可以使用的命令在第10.4节描述。

C-c a m  将匹配指定的标签集的所有标题生成一个列表。这个命令询问筛选规则，可以是标签的逻辑表达式，如 “+work+urgent-withboss” 或 “work|home” （见第 6 章）。如果你经常使用某个搜索，可以将它定义成一个命令。（见第 10.2 节）
C-c a M  同 C-c a m，但只复选同时也是 TODO 项的标题。                                                                         

匹配语法

搜索字符串可以使用 ‘&’ 作与运算， ‘|’ 作或运算。‘&’ 的约束力比 ‘|’ 的强。括号功能现在还没实现。用以搜索的元素可以是标签 、匹配标签的正则表达式、或者像 PROPERTY OPERATOR VALUE 这样带有比较操作符的用来比较属性值的表达式。第一个元素前面加 ‘-’ 表示不选匹配的项，加 ‘+‘ 表示选择匹配的项。使用 ’+‘ 和 ’-“ 时，与操作符 ‘&’ 就是可选的了。这里有一些只使用标签的例子。

”+work-boss“               选择标有”:work:“的标题，但去掉同时也标有”:boss:“的标题。。
”work|laptop“              选择标有”:work:“或者”:laptop:“的行。
”work|laptop+night“        跟前面相同，但要求标有”:laptop:“和行也要标有”:night:“。

匹配标签时你也可以尝试同时匹配属性，详细内容见手册。
***** 10.3.4 单文件时间轴


时间轴用时间排序视图概述单个文件中的所有带有时间戳的条目。这个命令的目的是用来给出一个工程中事件的鸟瞰图。
C-c a L	给出 Org 文件中所有带时间戳条目的排序视图。带有 C-u 前缀时，没有完成的 TODO 项（作了安排的以及没作安排的）也列在当前日期下。
***** 10.3.5 查找视图

这个议程视图用来对 Org 模式下的条目进行普通的文本查找。对于查找笔记很有用。
C-c a s	这个查找方式可以让你通过匹配子串或者用逻辑表达式指定关键字来选择条目。

例如，查找字符串 ”computer equipment“ 将会查找包含子串 ”computer equipment“ 的条目。查找视图也可以用布尔逻辑查找条目中的关键字。查找字符串 ”+computer +wifi -ethernet-{8\.11[bg]}“ 将会搜索包含关键字 computer 和 wifi 但不含 ethernet ，并且不被正则表达式 8\.11[bg] （排除 8.11b 和 8.11g） 匹配的笔记条目。

注意，除了议程文件，这条命令也会搜索 org-agenda-text-search-extra-files 中列出的文件。
*** agenda view 种类
日历视图，收集特定时期内的内容
An agenda that is like a calendar and shows information for specific dates
代办视图，收集所有代办事项
A TODO list that covers all unfinished action items.
匹配视图，根据输入的匹配内容和种类展示标题
A match view, showings headlines based on the tags, properties, and TODO state associated with them.
时间轴视图，根据时间顺序展示单个org文件中的事项
A timeline view that shows all events in a single org file, in time-sorted view.
文本搜索视图，略
A text search view that shows all entries from multiple files that contain
specified keywords
滞后项目视图，略
A stuck projects view showing projects that currently don’t move along.
自定义视图，可以为上述内容的组合
Custom views are special searches and combinations of different views.
***** Weekly/daily 视图
输入M-x org-agenda 时， 选择a 进入此视图。
在此视图中，操作在上一节介绍过。大家实践一下，通常使用的也就几个功能，碰到需要用的其他，再来查询具体快捷键。
***** ToDo 视图
输入M-x org-agenda 时， 选择t/T 进入此视图。
t， 列出所有的todo
T，可以选择特殊的key来进行过滤。
***** Tag和属性过滤视图
输入M-x org-agenda 时， 选择m/M 进入此视图。
m， 根据tag进行过滤

语法：
‘work’：  选择tag ‘:work:’.
‘work&boss’： 选择tag ‘:work:’ 和 ‘:boss:’.
‘+work-boss’： 选择tag ‘:work:’, 忽略 tag ‘:boss:’.
‘work|laptop’： 选择tag ‘:work:’ 或 ‘:laptop:’.
‘work|laptop+night’：选择有laptop 并且有night的tag

除了tag，还可以使用正则表达式，例如： ‘work+{^boss.*}’ ，选择带有work的tag并且以boss开头
更多的语法及表达式就不介绍了，有需要时，查文档获取。
***** search 试图
输入M-x org-agnda 时， 选择s 进入此视图。
根据关键字查找或者正则。
***** stuck project试图
输入M-x org-agnda 时， 选择# 进入此视图。
参考了David Allen的GTD方法，一个stuck的project是没有定义下一步action的日程，不会在todo显示
***** 分类
每个org todo文件都有一个分类，默认就是文件名。
可以在文件开头加入：

#+CATEGORY: xxx

可以在某项日程中加入属性：

:CATEGORY: xxx

之后在检索过滤时，可以根据分类来进行u过滤
***** Column 视图
列模式在上篇文章已经介绍过。
使用C-c C-x C-c 进入列模式。
此处不介绍了。

作者：机械猿
链接：https://www.jianshu.com/p/0d1c26abb7e6
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。
*** 10.4 议程缓冲区的命令

议程缓冲区中的条目链接到了它们的源 Org 或者日记文件。有一些命令可以用来显示和跳转到条目的源位置，也可以从视图缓冲区中”远程“编辑源文件。下面只是所有命令的一个选集，浏览 Agenda 菜单和手册获得完整的列表。

动作
n	下一行（同 DOWN 和 C-n）。13
p	上一行（同 UP 和 C-p）。14

查看/转到 Org 文件
mouse-3	
SPC	在另一个窗口中显示条目的源位置。带前缀使得整个条目在大纲中可见，而不只是标题。
TAB	在另一个窗口中条目的源位置。在 Emacs 22 之前的版本，mouse-1 也有这个功能。
RET	转到条目的源位置并删除其它的窗口。15

改变显示方式
o	删除其他的窗口。
d / w	切换到日/周视图。
f 和 b	时间前移或者后移来显示随后的 org-agenda-current-span 天。例如，如果显示了一周的内容，切换到下/上一周。
.	转到今天。
j	询问日期并转到那天。
v l 或简化为 l	触发日志模式（Logbook mode）。在日志模式中，当记录功能打开（变量 org-log-done）时标记为 DONE 的条目，以及在那天计时的条目，都会显示在议程中。
r 或 g	重新构造议程，以反映最新的状态。
s	保存当前 Emacs 会话的所有 Org 缓冲区和ID的地址。

二级筛选和查询编辑
/	根据标签过滤当前的缓冲区。提示你输入一个字母选择一个标签。先按‘-’排除一个标签。
\	通过增加条件缩小当前议程的视图。16

远程编辑（参考手册获得更多命令）
0-9	数字参数。
t	修改议程和 org 文件中的条目的TODO状态。
C-k	删除当前的议程条目以及源文件中它的整个子树。
C-c C-w	传送当前的条目。
C-c C-x C-a 或简作 a	用在 org-archive-default-command 中设置的默认归档命令对当前的条目对应的整个树进行归档。
C-c C-x C-s 或简作 $	归档当前标题对应的树。
C-c C-s	规划（Schedule）一个条目，带有前缀参数时删除规划时间戳。
C-c C-d	为条目设置截止期限，带前缀时删除截止期限。
S-RIGHT 和 S-LEFT	将与当前行相关的时间戳改变一天。
I	对当前条目开始计时。
O / X	暂停/取消最近开始的计时。
J	在另一个窗口中跳转到正在进行的计时。
*** TODO test
SCHEDULED: <2019-04-19 Fri>
*** 10.5 定制议程视图

自定义搜索的主要用途是对于频繁使用的搜索进行快捷键绑定，从而快捷地创建议程缓冲区或者稀疏树（当然后者只涵盖当前缓冲区的内容）。自定义的命令是用变量 org-agenda-custom-commands 来配置的。你可以用 C-c a C 来定制这个变量。也可以直接在 ”.emacs“ 中用 Emacs lisp 来设置。下面的例子包含了所有合法的搜索类型：

(setq org-agenda-custom-commands
      '(("w" todo "WAITING")
        ("u" tags "+boss-urgent")
        ("v" tags-todo "+boss-urgent")))

每个项的首字符串是使用调度器命令 C-c a 之后要给出的键以使用相应的命令。通常都是单个字符。第二个参数是搜索类型，接着是用来进行匹配的字符串或者正则表达式。上面的例子定义了：
C-c a w	对于包含关键字 ”“ 的 TODO 项的全局搜索。
C-c a u	对于带有标签 ”:boss:“ 而不含标签 ”:urgent:“ 的标题的全局标签搜索。
C-c a v	同搜索 C-c a u，但搜索范围只限于同时也是 TODO 项的标题。


*** 议程文件

org-agenda-files 为被提取的文件列表
可在Emacs启动配置文件中调整该变量。 比如

;; Collect all .org from my Org directory and subdirs
(load-library "find-lisp")
(setq org-agenda-files (find-lisp-find-files "~/MyPath/" "\.org$"))
--------------------- 
作者：skuldjf 
来源：CSDN 
原文：https://blog.csdn.net/skuldjf/article/details/78068111 
版权声明：本文为博主原创文章，转载请附上博文链接！
扩展阅读
手册第 10 章

Mat Lundin’s tutorial about custom agenda commands
John Wiegley’s setup
* 11 准备导出 基本语法

当导出 Org 模式的文档时，导出器在后端（backend）尽可能准确地反映出文档的结构。由于所要导出的目标文档像 HTML，LaTeX 和 DocBook 具有丰富的格式，Org 为富导出（rich export）提供了一些规则。这节概述 Org 模式缓冲区中的准备规则。
*** 11.1 结构的组成元素  （富文本格式）

***** 文档标题

导出文件的标题在特定行给出：

#+TITLE: This is the title of the document

***** 标题和章节

第二章描述的大纲结构确定了导出文档的结构基础。然而由于大纲结构也用于（比如说）列表和任务，因此只有前三个级别用作标题。更深的级别会被看作项目列表。你可以通过变量 org-export-headline-levels 在全局设置这个开关，或者只是在单个文件中设置：

#+OPTIONS: H:4

***** 目录表

目录表通常会直接插入在文档第一个标题之前。

#+OPTIONS: toc:2 (目录中只显示二级标题)
#+OPTIONS: toc:nil (无目录)

***** 段落、分行和引用

段落之间至少要有一空行。如果你想实现段内分行，可以在行后加上“\\”。

要想在一个区域内实现分行，而其他地方使用正常格式，你可以使用下面的构造，它也可以用来实现诗歌的格式：

#+BEGIN_VERSE
 Great clouds overhead
 Tiny black birds rise and fall
 Snow covers Emacs

     -- AlexSchroeder
#+END_VERSE

当从另外一个文档中引用一段话时通过会让它左右都缩进。在 Org 文档中可以这样作引用：

#+BEGIN_QUOTE
Everything should be made as simple as possible,
but not any simpler -- Albert Einstein
#+END_QUOTE

***** 如果你想让某些文本居中，可以这样：

#+BEGIN_CENTER
Everything should be made as simple as possible, \\
but not any simpler
#+END_CENTER

***** 强调和等宽 
你可以让文字 粗体 ， 斜体 ， 下划线 ， 代码 ，以及 逐文本 ，如果必需，也可以'划掉'。代码和逐文本的字符串不会以Org模式的语法格式来处理，会被逐字输出。想要插入一个水平格尺17，用一个只含有破折号的行来实现，要求至少有5个破折号。
#+BEGIN_SRC 
*事故* 加粗
_shi_  下划线
/等等/  无用

#+END_SRC
/等等/

***** 注释行

以‘#‘位于第 0 列的行会被看作注释，不会被导出。如果你想要一个缩进的行也被作为注释，用“#+”开头。另外以关键字 “COMMENT” 开头的子树整个树都不会被导出。最后，被 “#+BEGIN_COMMENT“ … ”#+END_COMMENT” 包围的整个区域也都不会被导出。
C-c ;	在一个项的开头触发 COMMENT 关键字
*** 11.2 图片和表格

对于 Org 模式的表格，以竖直线开头的行会成为表格的首行。你可以在表格前面用下面几行为表格指定标题和标签，以方便交叉引用，在文本中可以用 \ref{tab:basic-data} 来引用它：

#+CAPTION: This is the caption for the next table (or link)
#+LABEL: tbl:basic-data
   | ... | ... |
   |-----+-----|

一些后端（HTML，LaTeX，以及 DocBook）允许直接插入图片到导出的文档中。Org 也可以，只要图片的链接不含有描述部分就行了，例如：

[[./img/a.jpg]]

如果你希望为图片定义一个标题，或者一个标签方便内部交叉引用，可以让图片单独一行，在前面加上：

 #+CAPTION: This is the caption for the next figure link (or table)
 #+LABEL: fig:SED-HR4049
 [[./img/a.jpg]]

你也可以为图形指定一些其他的特性。但由于这与后端18密切相关，可以参考关于特定后端的章节获得详细信息。
*** 11.3 纯文本的例子

你可以包含进来一些纯文本的例子，这不属于准备的范畴。这些例子会等宽排版，所以适用于代码以及其他类似的情况：

#+BEGIN_EXAMPLE
Some example from a text file.
#+END_EXAMPLE

为了简单化，一些小型的例子也可以将各行以冒号开头。冒号前面可以有空格：

Here is an example
   : Some example from a text file.

对于一些程序设计语言的源代码以及一些其他的文本，可以被 Emacs 的字体锁（font-lock）特殊标记，你也可以让它们像在Emacs的缓冲区中那样显示：

#+BEGIN_SRC emacs-lisp
(defun org-xor (a b)
   "Exclusive or."
   (if a (not b) b))
#+END_SRC

为了能在支持这种语言的专门的缓冲区中编辑例子，可以用 C-c , 启动和退出编辑缓冲区。
*** 11.4 包含文件

当导出文档时，你可以包含其他文件中的内容。比如，想包含你的“.emacs”文件，你可以用：

#+INCLUDE: "~/.emacs" src emacs-lisp

可选的第二个第三个参数是组织方式（例如，“quote”，“example”，或者“src”），如果是 “src”，语言用来格式化内容。组织方式是可选的，如果不给出，文本会被当作 Org 模式的正常处理。用 C-c ,可以访问包含的文件。
***** TODO 11.5 嵌入 LaTex
SCHEDULED: <2019-05-05 日>

对于需要包含数学符号和特殊方程的科学笔记，Org 模式支持嵌入 LaTeX 代码到文件中。你可以直接使用类 TeX 的宏来输入特殊符号，输入方程，或者整个 LaTeX 环境。

Angles are written as Greek letters \alpha, \beta and \gamma. The mass if
the sun is M_sun = 1.989 x 10^30 kg. The radius of the sun is R_{sun} =
6.96 x 10^8 m. If $a^2=b$ and $b=2$, then the solution must be either
$a=+\sqrt{2}$ or $a=-\sqrt{2}$.

\begin{equation}
x=\sqrt{b}
\end{equation}

特殊设置之后，导出 HTML 时 LaTeX 代码片断会生成图片并包含进来。

扩展阅读
手册第11章
* 12 导出（富文本导出）

Org模式文档可以导出成多种格式：ASCII 用于包含在邮件中；HTML 用来发布到网页上；LaTeX/PDF 用来打印出漂亮的文档；DocBook 通过DocBook工具转换成其他各种各样的格式。也可以导出成 iCalendar 格式，将计划信息并入到桌面日历中。
12.1 导出选项

导出器能识别缓冲区中提供附加信息的特殊行。这样行可以放在文件中的任何地方。整个集合可以用 C-c C-e t 插入到缓冲区中。
C-c C-c t	插入导出选项模板，见下面的例子

#+TITLE:       the title to be shown (default is the buffer name)
#+AUTHOR:      the author (default taken from user-full-name)
#+DATE:        a date, fixed, of a format string for format-time-string
#+EMAIL:       his/her email address (default from user-mail-address)
#+DESCRIPTION: the page description, e.g. for the XHTML meta tag
#+KEYWORDS:    the page keywords, e.g. for the XHTML meta tag
#+LANGUAGE:    language for HTML, e.g. ‘en’ (org-export-default-language)
#+TEXT:        Some descriptive text to be inserted at the beginning.
#+TEXT:        Several lines may be given.
#+OPTIONS:     H:2 num:t toc:t \n:nil @:t ::t |:t ^:t f:t TeX:t ...
#+LINK_UP:     the ``up'' link of an exported page
#+LINK_HOME:   the ``home'' link of an exported page
#+LATEX_HEADER: extra line(s) for the LaTeX header, like \usepackage{xyz}
*** 12.2 导出调度器

所有的导出命令都可以通过导出调度器来使用，调度器是一个前缀快捷键，它会提示输入一个字母来指定命令。通常整个文件都会被导出，但是如果选中区域包含大纲树，就会导出大纲树，并以第一个标题作为文件标题。
C-c C-e	用来导出和发布的调度器
*** 12.3 ASCII/Latin-1/UTF-8 的导出

ASCII导出功能能给 Org 文件提供的一个简单易读的版本，它只包含纯 ASCII 文本。Latin-1 和 UTF-8 导出用它们能编码的特殊字符扩展了文件的功能。
C-c C-e a	导出 ASCII 文件
C-c C-e n 和 C-c C-e N	和上面的命令一样，但是用 Latin-1 编码19
C-c C-e u 和 C-c C-e U	和上面的命令一样，但是用 UTF-8 编码
*** 12.4 HTML的导出
C-c C-e h	导出 HTML 文件
C-c C-e b	导出 HTML 文件并用浏览器打开

想要将 HTML 以纯文本方式复制到导出文件，可以：

#+HTML: Literal HTML code for export

或者

 #+BEGIN_HTML
 All lines between these markers are exported literally
 #+END_HTML
*** 12.5 LaTeX和PDF的导出
C-c C-e l	导出 LaTeX 文件
C-c C-e p	导出 LaTeX 文件，并处理成 PDF 文件
C-c C-e d	导出 LaTeX 文件，处理成 PDF 文件，并打开

默认，LaTeX输出是使用article类型。但你可以在文件中通过选项 #+LaTeX_CLASS: myclass 来改变，但类型必须是 org-export-latex-classes 中列出的。

第 11.5 节撰述的内嵌的 LaTeX 可以正确地插入到 LaTeX 文件中。跟 HTML 导出器相似，也可以通过 #+LaTeX: 和 #+BEGIN_LaTeX ... #+END_LaTeX 来加入纯文本的 LaTex 代码。
***** test
#+BEGIN_LaTeX 
\documentclass{ctex}
\begin{document}
\section{高数笔记}
\subsection{思路}
$\int_{1}^{2}  cos(2x\pi)dx = \frac{1}{2\pi} cos(2x\pi) d(2\pi)$


\subsection{谨慎计算}
\subsection{题型及步骤}

sjshiidjiihiagosoajdialzjvjidijifiajjljlsidjifhhssoofjl
jlsjiejjanzjjjjzjzaqesxcderfv  vrfbgtunnnnmujiklop
ldhishowtime
sjhibbbdjo
jdkjirn
jiijijijiiijijjij

\end{document}


#+END_LaTeX


#+BEGIN_LaTeX  


h

#+END_LaReX

#+BEGIN_SRC latex
$ \int_{a}^{b}

#+END_SRC
*** 12.6 DocBook的导出
C-c C-e D	导出 DocBook 文件

跟 HTML 导出器相似，也可以通过 #+DocBook: 和 #+BEGIN_DocBook ... #+END_DocBook 结构来加入纯文本的 DocBook 代码。20
*** 12.7 iCalendar的导出
C-c C-e i	在一个 “.ice” 文件中为当前文件创建 iCalendar 项。
C-c C-e c	从 org-agenda-files 中的所有文件创建一个较大的 iCalendar 文件，并写入到 org-combined-agenda-icalendar-file 指定的文件中。

扩展阅读
手册第12章
Sebastian Rose’s image handling tutorial
Thomas Dye’s LaTeX export tutorial Eric Fraga’s BEAMER presentation tutorial
* 13 发布

Org 包含一个发布管理系统，可以配置一个由相互链接的 Org 文件组成的工程项目的自动向 HTML 转换。你也可以设置 Org，将导出的 HTML 页面和相应的附件如图片，源代码文件等自动上传到服务器。如何设置，详见手册。

下面是一个例子：

(setq org-publish-project-alist
      '(("org"
         :base-directory "~/org/"
         :publishing-directory "~/public_html"
         :section-numbers nil
         :table-of-contents nil
         :style "<link rel=\"stylesheet\"
 
		 href=\"../other/mystyle.css\"
                type=\"text/css\"/>")))

C-c C-e C	提示指明一个项目，将所有的文件发布。
C-c C-e P	发布包含当前文件的项目。
C-c C-e F	只发布当前文件。
C-c C-e E	发布所有项目。

Org 用时间戳来查看文件是否改变。上面的命令只发布修改过的文件。你可以给它们加上前缀来强制重新发布所有的文件。

扩展阅读
手册第 1 章
Sebastian Rose’s publishing tutorial
Ian Barton’s Jekyll/blogging setup
* 14 处理源代码

Org模式提供了一系列功能来处理源代码，包括源代码块的本地主模式编辑，代码块的运行(evaluation)，代码块的混合，以及以多种方式导出代码块和它们的结果。

** 代码块的结构

代码块的结构就像下面这样：

#+srcname: <name>
#+begin_src <language> <switches> <header arguments>
  <body>
#+end_src

#+srcname: test
#+begin_src python
  print('shi')
#+end_src

#+RESULTS:
: None

其中<name>是代码块的名称，<language>指定代码块的语言（例如，emacs-lisp，shell，R，python，等等），<switches>用以控制代码块的导出，<header arguments>用来从多个方面控制代码块的行为，下面会详述，最后<body>是我们要写的代码。

** 编辑源代码
c-c `
使用C-c `来编辑当前代码块。这个命令会新开一个以代码语言为主模式并包含代码的缓冲区（buffer）。保存这个缓冲区，会将新的内容写回Org缓冲区。再次使用C-c , 退出这个缓冲区。

** 运行代码块c-c c-c

用 C-c C-c 运行当前代码块并将它们的结果插入 Org 缓冲区中。默认情况下，运行功能只对 emacs-lisp 代码块开启，但支持多种语言。所支持语言的完整列表见手册。下面是一个代码块和它的结果。

#+begin_src emacs-lisp
  (+ 1 2 3 4)
#+end_src

#+results:
: 10


** 抽取源代码

用 C-c C-v 将代码块从一个 Org 模式的文件中抽取到“杂货库”（Library of Babel）中，这样在所有的 Org 模式的缓冲区中都可以运行该代码。一个常用的代码块集合在 contrib/library-of-babel.org 中随 Org 一直发布。

** 头参数

运行和导出代码时的很多选项都通过头参数来设置。选项可以指定为全局的，文件级别的，大纲子树级别的，或者只是用于一个代码块。下面解释部分头参数。
:var	:var头参数用来将参数传递给代码块。能用来传递给参数的值可以是直接量，org模式表格中的值，文字实例块(literal example blocks)中的值，或者一个已命名代码块的结果。

:results	:result头参数控制代码块结果的收集、类型和处理。output和value（默认）的值指定怎样在运行代码块时收集结果。vector，scalar，file， raw， html， latex 和 code的值指定代码块结果的类型并以此确定将结果并入Org缓冲区的方式。silent， replace， prepend和 append指定处理代码块结果的方式，明确是否以及如何将结果插入Org缓冲区中。

:session	:session头参数将会使代码块在Emacs的一个持续交互的底层进程（persistent interactive inferior process）中执行。这考虑到了代码运行的持续状态和运行结果的人工检查。

:exports	代码和块结果的任何组合在导出时都可以保持，这可以通过设置:results头参数为code results none或者both来指定。

:tangle	头参数:tangle yes将使代码块的内容到保存到一个以Org模式缓冲区命名的文件中。也可以通过:tangle filename指明文件名。

:cache	头参数:cache yes将使繁杂的代码块和结果关联，确保输入改变时代码块重运行。

:noweb	头参数:noweb将扩展运行和混合时的”noweb“样式的引用。

:file	将代码块结果输出到文件时（比如，图形，表格，图表）可以用头参数:file filename，结果会被保存至指定的文件中，在Org缓冲区中插入一个到该文件的链接。

扩展阅读
手册第 11.3 节
The Babel site on Worg
* 15 杂项
** 15.1 补全

Org 支持用 M-TAB 进行缓冲区内部的补全。这种补全不需要利用 minibuffer。你只需要键入几个字母然后用快捷键在原位补全。例如，这个命令可以在‘\’后面补全 TeX 符号，在标题的开头补全 TODO 关键字，在‘:’之后补全标签。
** 15.2 一个更清晰的大纲视图

当 Org 标题含有很多星号并且标题下面的文字不缩进时，就会显得杂乱无章。当写一个图书结构的文件时，大纲标题就是实际章节的标题，基于列表机大纲，上面的问题就不会再有，缩进的结构也会更清晰：

 * Top level headline 
 ** Second level 
 *** 3rd level
 some text 
 *** 3rd level
 more text 
 * Another top level headline

如果你用的 Emacs 23.1.50.3 和 Org 6.29 的更高版本，这种视图可以用 org-indent-mode 模式动态地实现，它会在每行前面加上一些前导空格。你可以通过设置变量 org-startup-indented 为所有的文件打开 org-indent-mode 模式，或者用

#+STARTUP: indent

为单个文件打开缩进。 如果你想在 Emacs 或者 Org 的早期版本中实现同样的效果，或者想让缩进用硬空格符号，以使得纯文本文件看起来一样。Org 可以缩进标题下面的文本（用TAB）;隐藏标题中的星号;只使用一级、三级等标题来为每级实现两个字符的缩进，从而实现这个功能。为了使这个特性在文件中支持，用：

#+STARTUP: hidestars odd

** 15.3 MobileOrg

MobileOrg 最初是由 Richard Moreland 为 iPhone/iPod Touch 系列设备开发的应用程序。Matt Jones也为Android设备独立实现了一个版本。详见Org手册。

note 本文的英文原文是 Org 主页上的一篇简短手册（ The compact Org-mode Guide ）。另外：

    本文的脚注是双向链接的，你可以大胆地查看脚注而不用担心如何再定位到原文。
    我不知道如何在引用的源代码中加脚注，如果你知道，希望你能告诉我。
    我不知道如果在表格中正确显示‘|’，如果你知道，希望你能告诉我。
    本文可能有错误，如果发现错误，请在评论中给出。

返回
Footnotes:

1 见说明。

2 当然你也可以专门用一个文件来记录待办事项，但这不是必需的。

3 对应的buffer中的设置是：#+STARTUP: logdone

4 对应的buffer中的设置是：#+STARTUP: lognotedone

5 跟所有的缓冲区内设置一样，用C-c C-c 使行中的改变生效。

6 这跟通常意义上的 安排一个会议 （ scheduling a meeting ）不同，后者只要在Org模式中插入一个不带关键字的时间戳就行了。

7 即使被标记为 DONE，在指定日期它依然会列在议程中。如果你不希望这样可以用变量 org-agenda-skip-scheduled-if-done 来设置。

8 截取位置是指保存截取信息的文件地址。

9 使用捕获模板，可以定义更细致的捕获地址，见[Capture templates]。

10 请设置你自己的快捷键，C-c c 只是一个建议。

11 这个表格实在翻译不通，以后再说吧。

12 注意，后两行中参数的顺序（月，日，年）依赖于 calendar-date-style 的设置。

13 原文是 C-p 有误。

14 原文是 C-n，有误。

15 在视图缓冲区的位置直接打开源位置，可能是版本的问题，并不删除其他的窗口。

16 不知道为什么我的版本不识别这个命令。

17 分隔线

18 （backend，导出目标）

19 可能是版本的问题，这个命令和下面的命令在我的机器上没有。

20 原文说是 LaTeX 代码，有误。

21 前面的逗号是命令的一部分，下同。

Date: 2012-09-26 Wed

Author: Hu Wenbiao

Org version 7.8.11 with Emacs version 24
Validate XHTML 1.0 
原文链接：http://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html#sec-9

搜索c-s [c-s]
粘贴
撤销
链接c-c c-o
窗口切换
窗口打开
窗口关闭
内部打开文件
行头尾
模板支持？
浏览器
  *网页链接另存为
  *网页另存为或者在网页上做笔记
emacs来学习
todo
支持多文件配置
Emacs 快速指南.（查看版权声明请至本文末尾）

【注意：位于【】之间的内容是译注，比如本行，下同。】

Emacs 键盘命令通常包含 CONTROL 键（有时候以 CTRL 或 CTL 来标示）和
META 键（有时候用 EDIT 或 ALT 来标示）。为了避免每次都要写出全名，我们
约定使用下述缩写：

 C-<chr>  表示当输入字符 <chr> 时按住 CONTROL 键。
          因此 C-f 就表示：按住 CONTROL 键再输入 f。

 M-<chr>  表示当输入字符 <chr> 时按住 META（或 EDIT 或 ALT）键。
          如果你的键盘上没有 META 、EDIT 或 ALT 键，用下述方法也等效：
          先按一下 ESC 键然后放开，再输入 <chr>。我们用 <ESC> 来表示
          ESC 键。

重要提示：要退出 Emacs，请用 C-x C-c（两个连续的组合键）。
要退出一个正在运行中的命令，请用 C-g。
下文中左边顶行的“>>”字样用来提示你尝试键盘命令。比如：




[本页当中特意留出一些空白是出于教学目的，请继续往后阅读]





>> 现在输入 C-v （查看下一屏文字）移动到下一屏。
   （别紧张，在输入字符 v 的同时注意要按住 CONTROL 键）
   从现在开始，每读完当前一屏你都需要这样做一次。

值得注意的是，当你从上一屏滚到下一屏时，中间会有两行的重复；这样做是为
了维持滚屏的连续性，方便你顺畅、连续地阅读。

用编辑器，开门第一件事就是学会在文字中移动。你已经知道了 C-v 可以向下移
动一屏，要往上移，请用 M-v （也就是按住 META 键，然后输入v，如果你没有
META、EDIT 或 ALT 键那么就先按 <ESC> 再按 v）。

>>  试试 M-v，然后再试试 C-v，来回遛几次。

** 查看快捷键
c-h c

* 16 正则表达式(regular expression)regexp
*** 正则生成
M-x re-builer  手动生成正则表达式
M-x regexp-builder 同上,手动生成正则表达式
M-x regexp-opt  根据目标内容生成对应的正则表达式
可以利用emacs的函数exgrep-opt自动生成一个高效的正则匹配表达式：
(regexp-opt '("foobar" "foobaz" "foo"))按键"C-x C-e"在状态栏生成正则表达式
(regexp-opt '("foobar" "foobaz" "foo"))按键"C-u C-x C-e"在当前光标处生成正则表达式
(regexp-opt '("foobar" "foobaz" "foo"))"\(?:foo\(?:ba[rz]\)?\)"
*** 正则显示
C-h s  (describe-syntax)显示在当前模式下的正则表达式规则描述
C-x w h   (highlight-regext)高亮显示正则表达式
C-x w r   (unhighlight-regext)取消高亮显示正则表达式
M-x list-matching-lines   显示包含正则表达式的整行
`\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}' 显示包含IPv4格式地址的行
注：在elisp代码中需要用2个反斜线\\进行转义，而在minibuffer中输入时，只需要1个\进行转义
在重复进行正则表达式操作时，可以直接用上、下光标按键，查看正则表达式的历史匹配记录
*** 特殊字符在Emacs正则表达式中的含义：
"." 匹配除了换行符之外任何单个字符的特殊字符。
"*" 自身不构成表达式的部分，是个后缀操作符，表示某个前导表达式重复任意次。
"+" 后缀操作符，与*作用相同。
"?" 后缀操作符，与"*"作用相似，匹配前导表达式至多出现1次（0次或1次重复）
"?,+?,??" 是前几个操作符的非贪心变体。正常的/+/?操作符是贪心的，只要总体上能够匹配，总是尽可能多的匹配。当有一个紧跟着?时就是非贪心：尽可能少的匹配。如：ab和ab?都能匹配a和abbbb，但同时多个匹配对象时，ab将匹配最长有效匹配abbbb，而ab?匹配最短有效匹配，仅匹配a。

"{N}" 指定重复次数为N的后缀操作符，前导表达式匹配了N次。
"{N,M}" 指定重复次数在N和M之间的后缀操作符，前导表达式至少匹配N次，但不超过M次。
"[ ... ]" 字符集范围，以“［"开始，以"]"结束，在两个方括号中间的字符就是这个集合能匹配的全部。可以用"-"放在开始字符与结束字符中间来指定匹配范围，如[a-z]匹配所有小写字母。字符集中的特殊字符：通常在字符集中的特殊字符不再特殊，但"]", "-", "^"情况特殊，如果想在集中包括"]"必须把它作为字符集中的第一个字符；想包括"-"必须把它作为字符集中的第一个或最后一个字符；想包括"^"必须把它放在除第一个字符以外的任何地方。
"1" 表示补集合，即匹配的字符是除掉指定的字符外其它所有的字符，"2"表示匹配除ASCII字母和数字外的所有字符。
"^" 仅匹配在文本中行首的那个空串的特殊字符
"$" 仅匹配行尾的空串
"" 引用特殊字符，包括"",如"&dollar;", "["；
"`" 匹配空串，但仅是接在缓冲区的开始处的。
"'" 匹配空串，但仅是接在缓冲区的尾部的。
"=" 匹配空串，但仅在"点"处的。
"b" 匹配空串，但仅在一个词的开始或者结尾的，如"bfoob"匹配任何作为单独的词出现的foo；"bballs?b"匹配作为单独的词出现的ball或balls。
"B" 匹配空串，但不在词的开始或结尾处。
" 匹配空串，但仅在词的开始处。仅当一个构成词的字符在缓冲区开始处时"\
">" 匹配空串，但仅在词的结尾处，仅当缓冲区尾部有构成词的字符时">"匹配缓冲区尾部的空串。
“w" 匹配任何构成词的字符，由语法表决定这些字符是什么。
"W" 匹配任何非构成词的字符
"sC" 匹配任何语法是C的字符，这里C是一个指定特定语法类的字符，如"w"为词的构成字符，"-"或" "为空白， "."为普通标点符号。
"SC" 匹配任何字符不属于语法C
"cC" 匹配任何属于种类C的字符，如"cc"匹配汉字， "cg"匹配希腊字符，用M-x describe-categories或查看已知种类。
"CC" 匹配所有不属于种类C的字符

  ] |产生附加的特殊结构:
"|" 指定一个选择 A | B 在表达式A与B中间时，首先匹配表达式A，如果匹配失败再匹配表达式B。"|"作用于两边最长可能的表达式，但是由"(...)"可以限制"|"的分组能力。
"(...)"分组结构有三种功能：
围住"|"的选择项： "(foo|bar)x" 可以匹配foox或者barx
围住复杂的表达式以实现后缀操作符（如"" "+" "?"）的操作： "ba(na)匹配如bananana等有任意个"na"串记录一个已匹配的子串用作后面的参考引用（并不是括号的n分组功能思想的结果）实际应用中，“分组功能”与“匹配参考引用”就注意，避免发生冲突，可以使用谨慎的分组"(?:...)",谨慎的分组不记录匹配的子串，不能用D来引用，在机械的结合正则表达式的时候有用，这样可以为语法目的加入分组，而不用干涉使用者写的分组的个数。
"D" 匹配和"(...)"结构第D次出现时所匹配的同样的文本。在"(...)"结构结束之后，匹配程序保存被这个结构匹配的文本，之后的正则表达式中，可以使用""跟着一个数字D来表示匹配和之前匹配结构第D次出现时所匹配的同样的文本。"(.*)1"匹配任何有完全相同的两部分而无换行符的串，"(...)"匹配前一半，可以是任意的串，"1"匹配后面的串，但必须和前面的完全相同。
*** 正则匹配替换

C-M-s  isearch-forward-regexp向前正则匹配
C-M-r  isearch-backward-regexp向后正则匹配
M-x    query-replace-regexp正则查询替换（对于每一次替换都要确认）
M-x    replace-regext正则替换（直接替换全部匹配的所有，不需要确认）
*** 正则表达式应用实例：

[a]正则搜索内容为"空格"或"<TAB>"：
按键：C-M-s： \|<tab>
按键说明：第1个按键为空格" "，第2个按键为"\|"是或者的意思，第3个按键为<TAB>，显示为"^I"。
Regexp I-search: \|^I

[b]正则搜索内容为"回车"：
按键：C-M-s：C-q C-j，显示为^J
Regexp I-search: ^J

[c]正则搜索内容为“Tab制表符“：
按键：C-M-s：<tab>，显示为^I
Regexp I-search: ^I

[d]查找IPv4格式的IP地址:
按键：C-M-s：\\(\[0-9\]\\{1,3\\}\\.\\)\\{3\\}\[0-9\]\\{1,3\\}
61\.139\.[0-9]\{1,3\}\.[0-9]\{1,3\}

[e]正则替换IP地址：(将所有61.139.*.* 替换为1.2.3.4)
按键：C-M-%：61\.139\.[0-9]\{1,3\}\.[0-9]\{1,3\}<RET>1.2.3.4
Query replace regexp (default 61\.139\.[0-9]\{1,3\}\.[0-9]\{1,3\} -> 1.2.3.4:

[f]正则替换：将多个空格或者TAB替换为1个空格
按键：C-M-%：[ C-q<TAB>]+<RET> <RET>
Query replacing [ ^I]+ with  : (? for help)
按键：C-M-%：
Query replace regexp (default [ ^I]+ ->  ): 

[g]正则替换：将从eshell下执行的命令结果拷贝至记录文件中后，替换掉命令结果中的shell命令提示符（ /mnt/sda5d/TDDownload/shell $  替换为 shell# )
按键：C-M-%：^/.* \$<RET>shell#<RET>
Query replace regexp (default ^/.* \$ -> shell#): 

[h]正则搜索所有"空格+行尾"（行尾以空格结束，在vim中是/ $）：
按键：C-M-s: +$

[i]正则替换：将多个空行替换为1个空行
按键：M-x replace-regexp:^C-q C-j $<RET><RET>
按键说明：^表示以什么开始，C-q C-j联合按键是一个回车，$表示行尾
Replace regexp (default ^^j$ -> ):

[j]正则替换：使用()()进行分组交换（将单词与冒号的组合abc:进行交换: abc）
按键：Ｍ-x replace-regexp:\([a-z]\{1,999\}\)\(\:\)<RET>\2 \1<RET>
按键说明：\(.....\)表示第１个分组，后面可以跟多个分组\(....\)\(.....\)在替换时分别以\1\2\3来表示之前定义的各个分组。

[k]正则替换：将css文件中abc{中间加个空格abc {
按键：M-x replace-regexp:\([a-z]+\)\({\)<RET>\1 \2<RET>
按键说明：在\(.....\)编组之间的字符直接用字符即可，不用加上\转义

[l]正则替换：将所有单词的首写字母替换为首写字母大写
按键：M-x replace-regexp:\(\w+\)<RET>\,(capitalize \1)<RET>
按键说明：在替换部分\,表示后面跟的不是要用来替换的东西，而是一段lisp程序

[m]正则替换：将所有匹配的文字后面加上一个回车
按键：M-x replace-regexp:\([a-z]+\)\({\)<RET>\&C-qC-j<RET>
按键说明：在替换部分用\&表示前面匹配的所有文字

[n]正则替换：将所有匹配的1 1-1 1-1-1替换为#1 #1-1 #1-1-1
按键：M-x replace-regexp:\(\([0-9]+\-\)*[0-9]+\)<RET>#\1
*** 示范：
原文为：
1
1-1
1-1-1
asfa saf  232-33, 11-22-33-44
smesf ijds  101-22-33-23
替换后：
#1
#1-1
#1-1-1
asfa saf  #232-33, #11-22-33-44
smesf ijds  #101-22-33-23

* 问题

*** win的ctrl-space冲突问题
[[https://www.cnblogs.com/wxgiter/archive/2011/12/01/3686287.html][一篇参考博客]]

*** win下乱码
确定是单个文件还是全部内容，
单个文件就重建。。全部就版本退回，不要随便尝试网上那些方法
存在乱码的原因是文件中含有不能识别的项（比如插入的时间）
***** 原因分析
感觉是因为自己打了错误的快捷键

******* TODO 以后有机会。将可能会引发问题的快捷键+yes or no
:LOGBOOK:  
- State "DONE"       from ""           [2019-01-06 日 15:41]
:END:      

*** win下插入时间的乱码问题
直接修改插入时间的格式即可：(setq system-time-locale "C")
* 小结（SUMMARY）
-----------------

以下命令在翻页浏览时相当有用：

        C-v     向前移动一屏
        M-v     向后移动一屏
        C-l     重绘屏幕，并将光标所在行置于屏幕的中央
                （注意是 CONTROL-L，不是 CONTROL-1）

>> 找到光标，留意其附近的文字，然后输入 C-l。
   找找光标在哪里，你会发现其附近的文字与之前相同，位置却变为屏幕的中心。
   如果你再次输入 C-l ，附近的文字将移动到屏幕的顶端。再次输入 C-l ，
   文字将移动到底端。

如果你的键盘上有 PageUp 和 PageDn，也可以用这两个键来滚屏。不过使用
C-v 和 M-v 的效率要更高一些。
* 共享粘贴板
[[https://blog.csdn.net/nicekwell/article/details/40063817][一篇博客]] 

* 多配置共存
不知道一开始是什么目的，我现在随便用，也挺方便的。
** 使用docker进行隔离
太复杂了
** 指定配置文件启动
没找到
** 使用git的版本控制

* 大师的配置
[[https://github.com/purcell/emacs.d][大师的配置github网址在这里]]
* 配置方法

配置文件位置?
建议不放在.emacs里，建议写在~/.emacs.d/init.el里，这样你可以把整个.emacs.d目录用git管理起来。
到别的电脑直接clone就好
直接copy大神的配置，十分方面，自己有了许多需求之后，就能使用lisp写完了
** 东拼西凑的配置教程
[[https://www.cnblogs.com/l137/p/3405967.html][emacs+w3m]]

[[https://www.jianshu.com/p/918449c6696c][orgmode自动换行]]


迫于在新系统中w3m的无力，不得不使用了emacs-eww

* 浏览器for emacs
*** eww
1.Emacs浏览器及快捷键 
M-x eww //进入浏览器 
************************eww浏览器快捷键******************************************** 
| 按键 | 函数               | 作用                         |
| w    | eww-copy-page-url  | 拷贝当前URL到kill ring(空格处为页面，链接处为链接 |
| u    |                    |猜测中                       |
| r    | eww-forward-url    | 前进到下一个URL              |
| q    | eww-quit           | 退出eww                      |
| g    | eww-reload         | 重载该页面                   |
| l    | eww-back-url       | 回退上一个URL                |
| H    | eww-list-histories | 显示浏览历史                 |
| b    | eww-add-bookmark   | 加书签                       |
| B    | eww-list-bookmarks | 显示书签列表                 |
| v    | eww-view-source    | 查看页面源代码               |
| C    | eww-cookie-list    | 列示Cookie                   |

|& |eww-browse-with-external-browser| 使用外部浏览器打开当前浏览的URL,外部浏览器由变量`shr-external-browser`决定 
|d |eww-download |下载光标所在的URL,下载的目录存在变量`eww-download-directory`中,默认为~/Downloads| 

*** w3m
***** 官方文档在[[http://emacs-w3m.namazu.org/][这里]]
***** w3m基本按键
q: 挂起

Q：退出
C-x k n RET 关闭第n个buffer， 若什么都不输入则关闭当前buffer

U:打开URL

v：打开文件(Bookmarks Aaron.bookmark)，查看书签

G: 在新的标签页中打开URL

g：在当前标签页中打开URL

S：用googl进行搜索(自定义的搜索引擎)

s: 历史(当前标签页的)

H: 主页

R: 刷新

B 返回

N 前进(RET)

RET: 打开衔接

\ 查看源代码

= 查看头信息

u 复制链接地址到剪贴板

c 复制本页地址到剪贴板
G 新建页面


T 显示图片

M-[ 缩小当前图片

M-] 放大当前图片

I 用外部查看器显示当前图片
页面操作

C-n 向下一行

C-p 向上一行

C-f 向前

C-b 向后

C-v 向下滚屏

M-v 向上滚屏

> 向右滚屏

< 向左滚屏

, 向左滚一格

. 向右滚一格

C-c C-w 删除当前页

C-c M-w 删除其他页
书签操作

a 添加当前页到书签

M-a 添加该URL到书签

C-c C-t 复制当前页到新标签

C-c C-p 上一个标签

C-c C-n 下一个标签

? E 编辑书签

? C-k 删除书
焦点操作

M-g 跳到第n行

C-c C-@ 标记当前位置

C-c C-v 跳到上次标记的位置

TAB 下一个衔接

M-TAB 上一个衔接
使用百度谷歌搜索

在出现的搜索框回车，然后在buffer会出现TEXT，在它后边输入你想要搜索的东东，然后回车，它就会出现在搜索框，之后再点击搜索的图标即可。其它的类似的搜索都可以这样办，你可通过这种方式登录chinaunix
其他重要操作

M 用外部浏览器打开当前页面

M-M 用外部浏览器打开当前URL

C-c C-k 停止载入

C-x C-w RET; ~/.w3m/pages/myfirstpage.org

eg:在emacs w3m下键入a, 然后会有session加入你想要保存到的文件夹的名字即可。如果想访问该文件夹只需要键入v,然后进行相应操作即可
Good News:

如果在浏览网页时很喜欢这个网页中的内容那么你可以这么做：

C-x C-w RET; ~/.w3m/pages/myfirstpage.org

实现链接编号
进入 w3m-lnum-mode, M-x w3m-lnum-mode; 按f显示链接编号



***** .el
  猜测插件文件夹在这里 /usr/share/emacs/site-lisp/w3m/
发现*search*里面有一些引擎的设置   在里面已有的引擎 可以直接在init中进行修改，但是问题来了，修改*search*后对emacs并没什么影响。
可以，在 /usr/share/emacs/site-lisp/w3m/中添加相关引擎内容之后，在init.el中修改：
(setq w3m-search-default-engine "bing")



***** 安装
安装链接在[[https://www.cnblogs.com/l137/p/3405967.html][这里]], 注意修改主页，

***** 简介
要浏览网页很简单,只需要执行M-x eww,然后输入网址,回车就行了. 若输入的不像是URL或者主机名,则eww会自动搜索关键字,至于使用哪个搜索引擎,则由变量`eww-search-prefix`来决定. 默认是https://duckduckgo.com

若想浏览本地页面,则有两种方法:

一种是执行M-x eww,在输入网址时使用file://xxx 的url

另一种是执行M-x eww-open-file,然后像find-file一样选择要打开的本地文件就行.
* TODO emacs +latext[/]
*** 要求功能：[/]
1. 数学公式
2. 图形
3. 实时渲染(pdf阅读器)
4. 同步对象
5. 片段：一段可复用的文本
   1. 一段签名
   2. 插入一个框
   3. UItiSnips
   4. 代码块与运行
   5. 插入的自成一体的小文件的部分（小note是这样的吗？）
   6. 上下标
   7. 
con
*** 性能
emacs只支持一部分的latex即时渲染

换行和第二行开始是不同的
具体见知乎收藏
*** 个人公式笔记
\frac
$$
\int
***** TODO [#A] latex绝对值怎么打
SCHEDULED: <2019-05-07 Tue 6:00>
- [ ] 同时用电脑看看我的数学都打的对吗
- [ ] 看看
  #+BEGIN_SRC 
\item 
  
  #+END_SRC
- 我的绝对值打的对吗
*** 资料
[[https://wenku.baidu.com/view/74251dc365ce0508763213d5.html][手册]]来自百度文库
[[http://117.128.6.12/cache/www.mohu.org/info/lshort-cn.pdf?ich_args2%3D468-05152320007493_ebb4f2e409c6ab413a287e44d4962b2a_10001002_9c89612bd7c7f0d19539518939a83798_f48d5199abd7921134efa7ce01554962][一份比较好看的手册]]
[[https://blog.csdn.net/libing403/article/details/71189148][公式大全]]
*** 方案
***** 混合方案
1. [ ] 使用tex编辑数学公式和内容（组成一体，最好只有一张）
2. [ ] 使用pdf 搜索
3. [ ] 使用emacs组织基本文档，少量公式可以使用tex写，然后转化为图片插入
4. 
   con
***** 纯emacs方案
见我的手机上
***** 在线方案
[[http://latex.codecogs.com/eqneditor/editor.php][在线公式编辑器]]

*** TODO emacs配置
***** 在emacs上安装的模块记录
******* ac-math is an available obsolete package.

     Status: Available Obsolete from melpa -- Install
    Archive: melpa

    Version: 20141116.2127
    Summary: Auto-complete sources for input of mathematical symbols and latex tags
   Requires: auto-complete-1.4, math-symbol-lists-1.0
   Homepage: https://github.com/vitoshka/ac-math
   Keywords: latex auto-complete unicode symbols 
Other versions: 20141116.2127 (installed).

This add-on defines three ac-sources for the
*[auto-complete](https://github.com/auto-complete)* package:

 * ac-source-latex-commands	- input latex commands
 * ac-source-math-latex       - input math latex tags  (by default, active only in math environments in latex modes)
 * ac-source-math-unicode     - input of unicode symbols (by default, active everywhere except math environments)

Start math completion by typing the prefix "\" key. Select the completion
type RET (`ac-complete`). Completion on TAB (`ac-expand`) is not that great
as you will see dummy characters, but it's usable.

(See https://github.com/vitoshka/ac-math#readme for more)
******* auctex-latexmk is an available obsolete package.
  Status: Available Obsolete from melpa -- Install
    Archive: melpa

    Version: 20170618.1636
    Summary: Add LatexMk support to AUCTeX
   Requires: auctex-11.87
   Homepage: https://github.com/tom-tan/auctex-latexmk/
   Keywords: tex 
Other versions: 20170618.1636 (installed).

This library adds LatexMk support to AUCTeX.

Requirements:
  * AUCTeX
  * LatexMk
  * TeXLive (2011 or later if you write TeX source in Japanese)

To use this package, add the following line to your .emacs file:
    (require 'auctex-latexmk)
    (auctex-latexmk-setup)
And add the following line to your .latexmkrc file:
    # .latexmkrc starts
    $pdf_mode = 1;
    # .latexmkrc ends
After that, by using M-x TeX-command-master (or C-c C-c), you can use
LatexMk command to compile TeX source.

For Japanese users:

LatexMk command automatically stores the encoding of a source file
and passes it to latexmk via an environment variable named "LATEXENC".
Here is the example of .latexmkrc to use "LATEXENC":
    # .latexmkrc starts
    $kanji    = "-kanji=$ENV{\"LATEXENC\"}" if defined $ENV{"LATEXENC"};
    $latex    = "platex $kanji";
    $bibtex   = "pbibtex $kanji";
    $dvipdf   = 'dvipdfmx -o %D %S';
    $pdf_mode = 3;
    # .latexmkrc ends

[back]
***** 有效参考[[https://blog.csdn.net/wdkirchhoff/article/details/41707157][在这里]] 其他的就需要自己去发现了
*** TODO 基本安装教程[/]
:LOGBOOK:  
CLOCK: [2019-05-05 日 10:03]--[2019-05-05 日 10:05] =>  0:02
:END:      

方案：emacs + textlive + auctex + sumatrapdf
按照[[https://blog.csdn.net/engreal/article/details/80704755][此博客]] 安装
更新源 报错
  (running on Debian, switching to user mode!)
  Cannot determine type of tlpdb from /home/work/texmf!
  cannot setup TLPDB in /home/work/texmf at /usr/bin/tlmgr line 6513.
 不想管这个问题了，过于麻烦，没什么用
sudo equivs-build texlive-local报错
  dh_testdir
  dh_testroot
  dh_prep
  dh_testdir
  dh_testroot
  dh_install
  dh_installdocs
  dh_installchangelogs
  dh_installchangelogs: 警告:     debian/changelog(l1): 格式损坏的头行
  LINE: <package name; defaults to equivs-dummy> (1.0) unstable; urgency=low
  dh_installchangelogs: 警告:     debian/changelog(l2): 在预想的 first heading 中发现空行
  dh_installchangelogs: 警告:     debian/changelog(l3): 在预想的 first heading 处发现更改的数据
  LINE:   * First version
  dh_installchangelogs: 警告: 未知信息 ''在输入 更新日志的已分析版本 中
  Can't locate object method "is_valid" via package "unknown" (perhaps you forgot to 
load "unknown"?) at /usr/share/perl5/Debian/Debhelper/Dh_Lib.pm line 1016.
  make: *** [debian/rules:24：binary-indep] 错误 255
  Error in the build process: exit status 2

***** 安装之后
group list：https://tug.org/usergroups.html

*****  Ubuntu下安装texlive并配置texstudio
2018年04月24日 22:09:00 My_leaf 阅读数：2159
版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/My_leaf/article/details/80071614

TeXLive 是由国际 TeX 用户组织 TUG 开发的 TeX 系统，支持不同的操作系统平台。其 Windows 版本又称 fpTeX,Unix/Linux 版本即著名的 teTeX 。
环境说明：
Ubuntu 16.04

******* 安装texlive
Ubuntu下 TeX Live 2018 的安装与配置
安装前准备

    下载texlive镜像
    https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/
    使用图形化安装界面，需要安装perl的tk组件
    sudo apt-get install perl-tk

安装TeX Live 2018
加载镜像文件

sudo mount -o loop texlive.iso /mnt
启动安装程序的图形化界面进行配置

cd /mnt
sudo ./install-tl -gui

点击完成，卸载镜像文件
cd /; sudo umount /mnt

******* 环境配置
划重点，安装后要进行环境变量等的配置
具体方法：
sudo gedit ~/.bashrc
在最后添加以下内容：

export MANPATH=${MANPATH}:/usr/local/texlive/2016/texmf-dist/doc/man
export INFOPATH=${INFOPATH}:/usr/local/texlive/2016/texmf-dist/doc/info
export PATH=${PATH}:/usr/local/texlive/2016/bin/x86_64-linux

    1
    2
    3

然后ctrl + s保存退出，输入source ~/.bashrc使更改生效。

******* 安装texstudio

在官方网站http://texstudio.sourceforge.net下载对应版本的deb安装包进行安装。
然后从option选项中进行配置
[[file:~/note/else/image/配置texstudio.png][配置界面]]
从右边的文件夹标志点进去选择就行，-src一类的附加内容会自己添加。
测试

新建tex文件，输入最基本的指令进行测试

\documentclass{article}

\begin{document}

  Hello latex!

\end{document}


成功后可以得到右边的编译结果。
注意如果不能编译中文，说明是build的编译器不行，推荐视同x类
***** TODO 使用emacs + textlive
*** 测试
[[file:text.txt][txt]]
* TODO [#C] 查查c-f折叠使用的是什么插件
* TODO 解决右下角标记内容的方
* TODO 如何实现在目录中查找
* TODO emacs的目录
在emacs的目录上添加一个功能
即con...
以应对新建目录中可能会存在的问题
<M-return> the command org-meta-return

初步使用宏解决了
以后可以尝试将宏绑定到 org-meta-return 上，但是不建议这么做，因为 org-meta-return上可能还有别的功能
但是可以尝试将M-enter直接与my绑定到一起
* TODO 设置议程文件位置
SCHEDULED: <2019-04-14 日>
*** 方案一 fall
(setq org-directory "~/Documents/Dropbox/0.GTD/")
*** 方案二
要不要自定义一个文件然后链接出去
1. [ ] 测试自定义的文件能否被使用
2. [ ] 链接与复制，将文件内容复制到相应位置
3. [ ] 测试同步效果
co
* conTODO 默认插入时间
如何做到插入你需要的时间；比如是循环还是单日执行
初步计划：应当处理好如何对付循环的情况，
设计两个对应
| 键1          | 键2          |
|--------------+--------------|
| 插入单个日期 | 插入循环日期 |
|              |              |
| done单个日期 | done循环日期 |
*** test

* TODO 在winemacs上安装词典
* test
[[./testlisp.lisp]]
* TODO emacs 图片
1. [ ] emacs 怎么插入图片  
   1. 插入链接
   2. 允许拖动
   3. 允许剪切，复制粘贴
2. 显示图片与否
3. 控制图片大小
* 参考资料：

--------------------- 
作者：engreal 
来源：CSDN 
原文：https://blog.csdn.net/engreal/article/details/80704755 
版权声明：本文为博主原创文章，转载请附上博文链接！
* 等待使用
1. [ ] org-bable
2. [ ] 
* TODO 任务序列
安排出一个任务序列表，体现出先后次序
* TODO 添加询问
隔一段时间会问你几个问题
比如这个问题可能是一个因变量，也可可能是用于内容的统计，总之有其特殊的用处
* TODO 处理电脑端是否同步图片
* TODO 输入法跳动问题
多半是输入法和右下方的显示不匹配
* DONE todo的更加快捷功能
CLOSED: [2019-06-01 六 11:16]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-06-01 六 11:16]
:END:      

功能要求
  1. [X] 快捷插入循环shedule 
不过你需要首先找到能够用代码替代宏的方法
  1. 永久宏？
  2. 如何用lisp代替操作，需要看一看别人怎么写的
con 

* TODO 关于wps的简单测试
SCHEDULED: <2019-07-07 Sun>
- [X] 先测试docx转org的剩余情况是什么样子的
  1. 保留图片吗？
  2. 保留链接吗？
  链接的处理还算可以，但是图片的转换实在不理想。
- [ ] 测试同一目录下的图片相互转换效果如何
- [ ] 转换到org的表格是什么意思，不是很明白
con

* [[https://www.cnblogs.com/bamanzi/archive/2011/02/28/emacs-cua-rectangle-cool.html][矩形块 ]]
就是将文本变为矩形块，方便阅读
* for 编程
为了编程准备的各种配置
*** 代码折叠
忘了启动的啥了，有空[[查查c-f折叠使用的是什么插件]]
c-c c-F  直接从最早的public 折叠了，再次按键会取消
c-c c-f  未定义

启动hs-minor-moded 后可使用如下命令
- c-c @ c-l   ：在谁前面折叠谁 能打开
  1. 折叠：在行开头使用，按本行记录级别
  2. 打开折叠：在折叠的省略号里面使用
- c-c @ c-c  ：在谁里面折叠谁
- c-c @ c-s  show 全部

- c-c @ c-M-h 全折叠
- c-c @ c-h  在谁里面折叠谁  不能打开
- c-c @ c-M-s 全显示
finish

*** 特别注释；在不改变内容的情况下进行大项目的注释
手动脚本其实也可，不一定非要一个插件，看功能和情况吧
*** 工程管理

***** 至少要实现的功能
- [ ] 工程管理
- [ ] 代码跳转
- [ ] 文件查找

*** 补足
***** DONE 关于补足，不能显示英文大小写的问题
CLOSED: [2019-02-11 一 18:47]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-02-11 一 18:47]
:END:      
我的补足，现在有两部分，一个是文字后出现的，一个是下拉的，只要在写代码时不出现问题就好
[[./test.java]]
没有问题了，再打开代码文件之后大小是区分的
但是在org文件里面就不行,两个都不区分大小写
* 关于emacs的网上资源
[[https://blog.csdn.net/redguardtoo/article/details/7222501/][一年成为emacs高手]]
[[https://www.emacswiki.org/emacs?interface=en][emacswiki]]
[[https://emacs-china.org/search?q=w3m][emacs中文社区]]
[[https://baike.baidu.com/item/emacs/2044183?fr=aladdin#4][一个比较全面的简介]]
emacs有诸多模式
* 前言 
emacs真的是操作系统 ，应该用emacs在尽量不折腾的情况下逐步配置自己的工作环境。
关于配置重点的考虑：尽量避免将其配置成ide以取代十分完整的环境。而应该努力将emacs配置成自己需要的模式，
自己需要什么的时候，就安装什么，逐渐完善自己的配置，适应自己的环境
* TODO  一个自动翻译的插件
所以我几个月前写了一个自动翻译的插件 [[https://github.com/manateelazycat/insert-translated-name][insert-translated-name.el]] 的插件, 当你需要输入英文文档, 注释或者函数
* TODO 和前沿友好交流
关于如何使用爬虫实现实时追踪emacs的最新、最酷用法，可以考虑使用每日新闻推送的方法
搜索emacs用法集合
  1. wiki
  2. github
  3. 中文社区
  4. 英文社区
  5. 
con
* TODO 自己写emacs配置
* emacs 的shell
回溯命令
| 命令  | 回溯的内容 |
|-------+------------|
| 箭头  | 输入       |
| alt-p | 输入       |
* 如何配置
*** 配置问题
stardict问题 如何启动.....
输入sudo  emacsui不支持输入法ssddff ddd
不输入sudo  启动shell一片空白 d 
想init.el写入注释#\\#时候报错，不知道为什么。

***** TODO 加入印象笔记   或者  丰富的手机支持
用c就可以  全是语句判断
*** TODO 学习purcell的顶尖配置 [6/8]
:LOGBOOK:  
- State "WAITING"    from "WAITING"    [2018-12-19 三 21:10]
- State "WAITING"    from "TODO"       [2018-12-19 三 21:05] \\
  目前暂时没有什么可以继续的部分，比如ide的全面配置等等，因为不写java和c等程序，暂时没有需求，自己写python'目前都是单文件也挺好的。
:END:      
***** TODO 现在的全部功能和快捷键
***** TODO 更多可能
如何快速的找到你需要的插件
***** DONE orgmode [2/2]
CLOSED: [2018-12-19 三 18:49]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 18:49]
:END:      
***** DONE 自动折行 [/]
CLOSED: [2018-12-19 三 18:48]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 18:48]
:END:      
***** DONE todo
CLOSED: [2018-12-19 三 18:49]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 18:49]
:END:      
***** DONE 编辑器功能
CLOSED: [2018-12-19 三 21:04]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 21:04]
:END:      
***** DONE TDDO 补全
CLOSED: [2018-12-19 三 18:55]
:LOGBOOK:  
- State "DONE"       from ""           [2018-12-19 三 18:55]
:END:      
***** java 
***** DONE python
CLOSED: [2018-12-19 三 18:49]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 18:49]
:END:      
*****  c
***** 使用purcell中遇到的问题
[[http://blog.sina.com.cn/s/blog_1313062e90102w0oi.html][在这里开始Steve Purcell]]
******* 网络不通 
最后注意修改网络：
   3.更改.emacs.d/lisp/init-elpa.el
   ;;; Standard package repositories
   (add-to-list 'package-archives
   '("popkit" . "https://elpa.popkit.org/packages/"))

******* 链接超时 
升级大神配置遇到的问题：Warning (initialization): // An error occurred while loading ‘/home/work/.emacs.d/init.el’:
File error: Failed connect, 连接超时

To ensure normal operation, you should investigate and remove the
cause of the error in your initialization file.  Start Emacs with
the ‘--debug-init’ option to view a complete error backtrace.

查看debug之后：Debugger entered--Lisp error: (error "Selecting deleted buffer")
  signal(error ("Selecting deleted buffer"))
  package-install-from-archive([cl-struct-package-desc mmm-mode (0 5 7) "Allow Multiple Major Modes in a buffer" ((cl-lib (0 2))) tar "gnu" nil ((:keywords "convenience" "faces" "languages" "tools") (:url . "https://github.com/purcell/mmm-mode")) nil])
  mapc(package-install-from-archive ([cl-struct-package-desc mmm-mode (0 5 7) "Allow Multiple Major Modes in a buffer" ((cl-lib (0 2))) tar "gnu" nil ((:keywords "convenience" "faces" "languages" "tools") (:url . "https://github.com/purcell/mmm-mode")) nil]))
  package-download-transaction(([cl-struct-package-desc mmm-mode (0 5 7) "Allow Multiple Major Modes in a buffer" ((cl-lib (0 2))) tar "gnu" nil ((:keywords "convenience" "faces" "languages" "tools") (:url . "https://github.com/purcell/mmm-mode")) nil]))
  package-install(mmm-mode)
  (if (cl-find-if (function (lambda (v) (version-list-|<|= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t)))
  (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-|<|= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t))))
  (or (package-installed-p package min-version) (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-|<|= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t)))))
  (lambda (package &optional min-version no-refresh) "Install given PACKAGE, optionally requiring MIN-VERSION.\nIf NO-REFRESH is non-nil, the available package lists will not be\nre-downloaded in order to locate PACKAGE." (or (package-installed-p package min-version) (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-|<|= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t))))))(mmm-mode)
  apply((lambda (package &optional min-version no-refresh) "Install given PACKAGE, optionally requiring MIN-VERSION.\nIf NO-REFRESH is non-nil, the available package lists will not be\nre-downloaded in order to locate PACKAGE." (or (package-installed-p package min-version) (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-|<|= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t)))))) mmm-mode nil)
  (let ((available (apply oldfun package args))) (prog1 available (if (and available (boundp (quote package-selected-packages))) (progn (add-to-list (quote sanityinc/required-packages) package)))))
  sanityinc/note-selected-package((lambda (package &optional min-version no-refresh) "Install given PACKAGE, optionally requiring MIN-VERSION.\nIf NO-REFRESH is non-nil, the available package lists will not be\nre-downloaded in order to locate PACKAGE." (or (package-installed-p package min-version) (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-|<|= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t)))))) mmm-mode)
  apply(equiring MIN-VERSION.\nIf NO-REFRESH is non-nil, the available package lists will not be\nre-downloaded in order to locate PACKAGE." (or (package-installed-p package min-version) (let* ((known (cdr (assoc package package-archive-contents))) (versions (mapcar (function package-desc-version) known))) (if (cl-find-if (function (lambda (v) (version-list-|<|= min-version v))) versions) (package-install package) (if no-refresh (error "No version of %s >= %S is available" package min-version) (package-refresh-contents) (require-package package min-version t)))))) mmm-mode)
  require-package(mmm-mode)
  eval-buffer(#|<|buffer  *load*-174381> nil "/home/work/.emacs.d/lisp/init-mmm.el" nil t)  ; Reading at buffer position 210
  load-with-code-conversion("/home/work/.emacs.d/lisp/init-mmm.el" "/home/work/.emacs.d/lisp/init-mmm.el" nil t)
  #|<|subr require>(init-mmm)
  apply(#|<|subr require> init-mmm nil)
  (prog1 (apply orig feature args) (if (and (not already-loaded) (memq feature features)) (progn (let ((time (sanityinc/time-subtract-millis (current-time) require-start-time))) (add-to-list (quote sanityinc/require-times) (list feature require-start-time time) t)))))
  (let* ((already-loaded (memq feature features)) (require-start-time (and (not already-loaded) (current-time)))) (prog1 (apply orig feature args) (if (and (not already-loaded) (memq feature features)) (progn (let ((time (sanityinc/time-subtract-millis ... require-start-time))) (add-to-list (quote sanityinc/require-times) (list feature require-start-time time) t))))))
  sanityinc/require-times-wrapper(#|<|subr require> init-mmm)
  apply(sanityinc/require-times-wrapper #|<|subr require> init-mmm)
  require(init-mmm)
  eval-buffer(#|<|buffer  *load*> nil "/home/work/.emacs.d/init.el" nil t)  ; Reading at buffer position 2748
  load-with-code-conversion("/home/work/.emacs.d/init.el" "/home/work/.emacs.d/init.el" t t)
  load("/home/work/.emacs.d/init" t t)
  #[0 "\205\266\00	\306=\203\00\307\310Q\202?\00	\311=\204\00\307\312Q\202?\00\313\307\314\315#\203*\00\316\202?\00\313\307\314\317#\203>\00\320\321\322!D\nB\323\202?\00\316\324\325\324\211#\210\324=\203e\00\326\327\330\307\331Q!\"\325\324\211#\210\324=\203d\00\210\203\247\00\332!\333\232\203\247\00\334!\211\335P\336!\203\201\00\211\202\214\00\336!\203\213\00\202\214\00\314\262\203\245\00\337\"\203\243\00\340\341#\210\342\343!\210\266\f?\205\264\00\314\325\344\324\211#)\262\207" [init-file-user system-type delayed-warnings-list user-init-file inhibit-default-init inhibit-startup-screen ms-dos "~" "/_emacs" windows-nt "/.emacs" directory-files nil "^\\.emacs\\(\\.elc?\\)?$" "~/.emacs" "^_emacs\\(\\.elc?\\)?$" initialization format-message "`_emacs' init file is deprecated, please use `.emacs'" "~/_emacs" t load expand-file-name "init" file-name-as-directory "/.emacs.d" file-name-extension "elc" file-name-sans-extension ".el" file-exists-p file-newer-than-file-p message "Warning: %s is newer than %s" sit-for 1 "default"] 7]()
  command-line()
  normal-top-level()

******* font tty not defined
具体问题是由于emacs的bug导致的（以24版本作为代表），由于进入shell之后会保存用户信息到tty最终生成了此结果，

具体描述在github purcell/emacs.d/issues/259
问题发生在进入shell之后再进入gun

********* 解决方案
运行：
#+BEGIN_SRC 
emacsclient -nw& 到client停止即可

#+END_SRC

*** DONE 插件推荐
CLOSED: [2018-12-19 三 19:01]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 19:01]
:END:      
[[https://linux.cn/article-6891-1.html][桌面应用：暴增生产力]]
虽然我主要侧重于与编程相关的生产力提升，但是这些插件对所有人或不同用途                                                                                                                        
***** 1. Ido-mode                                                                                                          
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
Ido 或许是对新手最有用的一个插件，Ido 的意思是交互式工作（                                                           
interactively do）。它取代了大部分的用花哨字符匹配菜单的枯燥提示。好比                                               
说，它用列出了当前目录所有文件的列表来取代了常规的打开文件提示符。输入                                               
一些字符，Ido 将尝试匹配最合适的文件。它通过可视化让你的操作变得更容易                                               
，这也是一个快速遍历所有文件都有相同前缀的文件夹的方法。                                                             

***** 2. Smex                                                                                                              
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
它不算最著名的一个、但却是一个替代 Ido-mode 的好选择：Smex 可以优雅的                                                
替代普通的M-x提示符，灵感大部分来自于 Ido-mode。它也给调用M-x后输入的                                                
命令带来了同样的交互搜索能力。它简单而有效，是一个为常用操作提升效率的                                               
最好方法。                                                                                                           

***** 3. Auto Complete                                                                                                     
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
知道这个插件的存在之前，我在 Emacs 里面有一半的时间花在敲击 M-/ 来补完                                               
单词上。现在，我有一个漂亮的弹出菜单可以为我做自动补全。无须多说，我们                                               
都需要它。                                                                                                           

***** TODO [#C] 4. YASnippet                                                                                                         
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
这是真正的程序员必备利器。总有一些代码片段会让我们觉得我们一辈子都在写                                               
它。对我来说，就是调试 PHP 时不断输入的 var_dump(...);exit;。经过一段                                                
时间一遍又一遍的输入var_dump(...);exit;，我觉得我可以预先把其做成录制                                                
好的、方便用到的代码片段。使用 YASnippets，可以很容易导入代码片段文件                                                
或者自己做个。之后，只要按下一个 tab 键，就可以将一个小的关键词扩展成                                                
一大段预先写好的代码，然后可以很方便地在里面修改。                                                                   

***** 5. Org-mode                                                                                                          
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
免责声明，我最近才开始使用 Org-mode，但它已经深深的吸引了我。从我看过                                                
数以百计的文章来说，Org-mode 可以改变你的生活。它背后的想法很简单：它                                                
是一种用普通文本做简单备注的模式，可以很容易地在任务列表和各种数据中转                                               
来转去，并进行一些比如按优先级或到期日期的过滤，或设置一个重复日期。然                                               
而，虽然思路简单，但你可以做到很多，用各种方法用于各种用途。与其去看一                                               
个长长的介绍，我觉得你可以去读读现有教程，有很多视频可以看，自己去体验                                               
一下 Org-mode 是多么强大。                                                                                           

***** 6. Helm                                                                                                              
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
一些使用者喜欢它，但是其他人没有这么大的使用热情。我是后者的一部分。但                                               
在拥有这样一个庞大的追随者的情况下，是不能不提到它的。Helm 旨在完全变                                                
换你的 Emacs 使用体验。简单来说，Helm 是一个在 Emacs 中帮助你快速找到                                                
一个文件或命令的框架。根据你的输入，它将尝试使用词语自动完成来引导你将                                               
大脑的念头变为行动。起初感觉有点奇怪，但对一些人来说，Helm 本身就是一                                                
个信仰。虽然我不是 Helm 的粉丝，我欣赏 helm-occur 这一个伟大的工具可以                                               
在一个大文档搜索字符串并且在一个单独的缓冲区显示所有匹配结果，以便很容                                               
易在它们之间跳转。如果你正在寻找一个快速演示来了解 Helm 能做什么，我推                                               
荐这篇文章。                                                                                                         

***** 7. ace-jump-mode                                                                                                     
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
这是另一个有一大群追随者的插件，我正在试图成为 ace-jump-mode 的粉丝。                                                
掌握这个插件，你会体验到超越鼠标感受。简单描述一下，通过你选择的快捷方                                               
式触发 ace-jump-mode 后，你会被提示输入字符。输入一个字符，所有以该字                                                
符开头的单词中的那个字符就会替换成一个唯一字符并被高亮。输入一个屏幕上                                               
的高亮字符，你的光标会直接跳转到高亮显示的那个词。我不得不承认，这让我                                               
使用它时有点反应不过来，但是，一旦你掌握它，它将显著提升你在一个文档里                                               
的移动速度。（LCTT 译注：用文字描述比较困难，如截图中，你输入的是一个                                                
“i”，然后屏幕中所有以“i”开头的单词中的那个“i”都被替换成了从 a 到 z 的                                                
字符，并高亮；你可以输入这些高亮的字符直接跳转到那个位置。）                                                         

***** TODO [#C] 8. find-file-in-project                                                                                              
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
如果你喜欢 Sublime text 以及它可以用非常方便的Ctrl-p模糊搜索来打开一个                                               
项目中的任何文件的功能，你将会喜欢上 find-file-in-project （简称 ffip                                                
）的。使用设置指定了您的版本控制的根文件夹后，您可以轻松地调出一个很酷                                               
的文本条，通过快速扫描和搜索你的代码，来根据你输入的名称找到匹配的文件                                               
。我喜欢把它绑定到键盘上的 F6 键。如果你不知道整个目录从上到下的复杂结                                               
构，这很简单，而且非常易用。                                                                                         

***** 9. Flymake                                                                                                           
                                                                                                                     
[1601151648]                                                                                                         
                                                                                                                     
对 IDE 的爱好者来说，我认为语法检查器是 IDE 最强大的特性之一，它非常适                                               
合初学者和方便了那些疲惫的程序员。感谢 Flymake，Emacs 用户也可以享受到                                               
了语法检查器。因为我工作中用 PHP 很多，Flymake 就不需要任何额外的配置                                                
。当我写代码的时候，它会自动检查我的代码和高亮任何一个包含问题的行。对                                               
于编译语言，Flymake 将寻找一个用于检查你的代码的 Makefile。真神奇。                                                  

***** DONE 10. electric-pair                                                                                                    
CLOSED: [2018-12-19 三 21:18]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2018-12-19 三 21:18]
:END:      
                                                                                                                     
最后，但并非最不重要，在我看来，electric-pair 是最简单但最强大的插件之                                               
一。它会自动关闭你输入的括号。它起初看起来并不是很有用，但相信我，在被                                               
寻找配对括号折磨几百次之后，你会很高兴有这么一个插件，可以确保你所有的                                               
表达式的括号都是一一对应的。                                                                                         
                                                                                                                     
总结一下，Emacs 是一个奇妙的工具。这可不是一个令人惊讶的说法。试试这些                                               
插件，看着你的效率直线飙升吧。这个列表当然不是详尽的列表。如果你想贡献                                               
你的建议，请在评论中这样做。我自己一直在寻找新的插件来试着发现 Emacs                                                 
的新体验。                                                                                                           
                                                                                                                     
为Emacs配置newLISP开发环境                                                                                           

* 多配置共存
不知道一开始是什么目的，我现在随便用，也挺方便的。
** 使用docker进行隔离
太复杂了
** 指定配置文件启动
没找到
** 使用git的版本控制

*** 大师的配置
[[https://github.com/purcell/emacs.d][大师的配置github网址在这里]]
*** 配置方法


配置文件位置?
建议不放在.emacs里，建议写在~/.emacs.d/init.el里，这样你可以把整个.emacs.d目录用git管理起来。
到别的电脑直接clone就好
直接copy大神的配置，十分方面，自己有了许多需求之后，就能使用lisp写完了
***** 东拼西凑的配置教程
[[https://www.cnblogs.com/l137/p/3405967.html][emacs+w3m]]

[[https://www.jianshu.com/p/918449c6696c][orgmode自动换行]]


迫于在新系统中w3m的无力，不得不使用了emacs-eww

* 终端 
emacs的终端属于哑终端，在安装一些软件的时候，不能配置图形界面，因此安装软件不要从这里开始

* emacs for programming

*** 跳转
[[https://www.cnblogs.com/elvalad/p/4069656.html][未检测教程一]]
*** Programming Emacs in Lisp and C
s +latext[/]
*** 要求功能：[/]
1. 数学公式
2. 图形
3. 实时渲染(pdf阅读器)
4. 同步对象
5. 片段：一段可复用的文本
   1. 一段签名
   2. 插入一个框
   3. UItiSnips
   4. 代码块与运行
   5. 插入的自成一体的小文件的部分（小note是这样的吗？）
   6. 上下标
   7. 
con
*** 性能
emacs只支持一部分的latex即时渲染

换行和第二行开始是不同的
具体见知乎收藏
*** TODO for python
**** TODO 生效env的方法
使用的话
1. 指定母目录
2. 使用restart


### Restarting in virtualenv env2 (/home/work/programme/env/env2/)
###


Python 2.7.15+ (default, Oct  2 2018, 22:12:08) 
[GCC 8.2.0] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> python.el: native completion setup loaded
***** DONE 测试
CLOSED: [2019-11-24 日 16:20]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-11-24 日 16:20]
:END:      
- [X] ../
- [X] ./
- [X] ├── bin
- [X] ├── include
- [X] │   └── python2.7 -> /usr/include/python2.7
- [X] ├── lib
- [X] │   └── python2.7
- [ ] │       ├── distutils
- [ ] │       ├── encodings -> /usr/lib/python2.7/encodings
- [ ] │       ├── lib-dynload -> /usr/lib/python2.7/lib-dynload
- [X] │       └── site-packages
- [ ] │           ├── docx-0.2.4.dist-info
- [ ] │           ├── lxml
- [ ] │           │   ├── html
- [ ] │           │   ├── includes
- [ ] │           │   │   ├── libexslt
- [ ] │           │   │   ├── libxml
- [ ] │           │   │   └── libxslt
- [ ] │           │   └── isoschematron
- [ ] │           │       └── resources
- [ ] │           │           ├── rng
- [ ] │           │           └── xsl
- [ ] │           │               └── iso-schematron-xslt1
- [ ] │           ├── lxml-4.4.1.dist-info
- [ ] │           ├── mysql
- [ ] │           │   └── connector
- [ ] │           │       ├── django
- [ ] │           │       ├── fabric
- [ ] │           │       └── locales
- [ ] │           │           └── eng
- [ ] │           ├── mysql_connector-2.2.9.dist-info
- [ ] │           ├── MySQLdb
- [ ] │           │   └── constants
- [ ] │           ├── MySQL_python-1.2.5.dist-info
- [ ] │           ├── mysqlx
- [ ] │           │   ├── locales
- [ ] │           │   │   └── eng
- [ ] │           │   └── protobuf
- [ ] │           ├── pdfminer
- [ ] │           ├── pdfminer-20140328.dist-info
- [ ] │           ├── PIL
- [ ] │           ├── Pillow-6.1.0.dist-info
- [ ] │           ├── pip
- [ ] │           │   ├── _internal
- [ ] │           │   │   ├── cli
- [ ] │           │   │   ├── commands
- [ ] │           │   │   ├── distributions
- [ ] │           │   │   ├── models
- [ ] │           │   │   ├── operations
- [ ] │           │   │   ├── req
- [ ] │           │   │   ├── utils
- [ ] │           │   │   └── vcs
- [ ] │           │   └── _vendor
- [ ] │           │       ├── cachecontrol
- [ ] │           │       │   └── caches
- [ ] │           │       ├── certifi
- [ ] │           │       ├── chardet
- [ ] │           │       │   └── cli
- [ ] │           │       ├── colorama
- [ ] │           │       ├── distlib
- [ ] │           │       │   └── _backport
- [ ] │           │       ├── html5lib
- [ ] │           │       │   ├── filters
- [ ] │           │       │   ├── treeadapters
- [ ] │           │       │   ├── treebuilders
- [ ] │           │       │   ├── treewalkers
- [ ] │           │       │   └── _trie
- [ ] │           │       ├── idna
- [ ] │           │       ├── lockfile
- [ ] │           │       ├── msgpack
- [ ] │           │       ├── packaging
- [ ] │           │       ├── pep517
- [ ] │           │       ├── pkg_resources
- [ ] │           │       ├── progress
- [ ] │           │       ├── pytoml
- [ ] │           │       ├── requests
- [ ] │           │       ├── urllib3
- [ ] │           │       │   ├── contrib
- [ ] │           │       │   │   └── _securetransport
- [ ] │           │       │   ├── packages
- [ ] │           │       │   │   ├── backports
- [ ] │           │       │   │   ├── rfc3986
- [ ] │           │       │   │   └── ssl_match_hostname
- [ ] │           │       │   └── util
- [ ] │           │       └── webencodings
- [ ] │           ├── pip-19.2.3.dist-info
- [ ] │           ├── pkg_resources
- [ ] │           │   ├── extern
- [ ] │           │   └── _vendor
- [ ] │           │       └── packaging
- [ ] │           ├── pkg_resources-0.0.0.dist-info
- [ ] │           ├── setuptools
- [ ] │           │   ├── command
- [ ] │           │   ├── extern
- [ ] │           │   └── _vendor
- [ ] │           │       └── packaging
- [ ] │           ├── setuptools-41.2.0.dist-info
- [ ] │           ├── wheel
- [ ] │           │   └── cli
- [ ] │           └── wheel-0.33.6.dist-info
- [X] ├── local
- [X] │   ├── bin -> /home/work/programme/env/env2/bin
- [X] │   ├── include -> /home/work/programme/env/env2/include
- [X] │   └── lib -> /home/work/programme/env/env2/lib
- [X] └── share
- [X]     └── python-wheels
- [ ] ├── docx-template
- [ ] │   ├── docProps
- [ ] │   ├── _rels
- [ ] │   └── word
- [ ] │       └── theme
*** 个人公式笔记
\frac
$$
\int
* TODO emacs for latex
*** TODO [#A] latex绝对值怎么打
SCHEDULED: |<|2019-05-07 Tue 6:00>
- [ ] 同时用电脑看看我的数学都打的对吗
- [ ] 看看
  #+BEGIN_SRC 
\item 
  
  #+END_SRC
- 我的绝对值打的对吗
** 资料
[[https://wenku.baidu.com/view/74251dc365ce0508763213d5.html][手册]]来自百度文库
[[http://117.128.6.12/cache/www.mohu.org/info/lshort-cn.pdf?ich_args2%3D468-05152320007493_ebb4f2e409c6ab413a287e44d4962b2a_10001002_9c89612bd7c7f0d19539518939a83798_f48d5199abd7921134efa7ce01554962][一份比较好看的手册]]
[[https://blog.csdn.net/libing403/article/details/71189148][公式大全]]
** 方案
**** 混合方案
1. [ ] 使用tex编辑数学公式和内容（组成一体，最好只有一张）
2. [ ] 使用pdf 搜索
3. [ ] 使用emacs组织基本文档，少量公式可以使用tex写，然后转化为图片插入
4. 
   con
**** 纯emacs方案
见我的手机上
**** 在线方案
[[http://latex.codecogs.com/eqneditor/editor.php][在线公式编辑器]]

** TODO emacs配置
**** 在emacs上安装的模块记录
****** ac-math is an available obsolete package.

     Status: Available Obsolete from melpa -- Install
    Archive: melpa

    Version: 20141116.2127
    Summary: Auto-complete sources for input of mathematical symbols and latex tags
   Requires: auto-complete-1.4, math-symbol-lists-1.0
   Homepage: https://github.com/vitoshka/ac-math
   Keywords: latex auto-complete unicode symbols 
Other versions: 20141116.2127 (installed).

This add-on defines three ac-sources for the
*[auto-complete](https://github.com/auto-complete)* package:

 * ac-source-latex-commands	- input latex commands
 * ac-source-math-latex       - input math latex tags  (by default, active only in math environments in latex modes)
 * ac-source-math-unicode     - input of unicode symbols (by default, active everywhere except math environments)

Start math completion by typing the prefix "\" key. Select the completion
type RET (`ac-complete`). Completion on TAB (`ac-expand`) is not that great
as you will see dummy characters, but it's usable.

(See https://github.com/vitoshka/ac-math#readme for more)
****** auctex-latexmk is an available obsolete package.
  Status: Available Obsolete from melpa -- Install
    Archive: melpa

    Version: 20170618.1636
    Summary: Add LatexMk support to AUCTeX
   Requires: auctex-11.87
   Homepage: https://github.com/tom-tan/auctex-latexmk/
   Keywords: tex 
Other versions: 20170618.1636 (installed).

This library adds LatexMk support to AUCTeX.

Requirements:
  * AUCTeX
  * LatexMk
  * TeXLive (2011 or later if you write TeX source in Japanese)

To use this package, add the following line to your .emacs file:
    (require 'auctex-latexmk)
    (auctex-latexmk-setup)
And add the following line to your .latexmkrc file:
    # .latexmkrc starts
    $pdf_mode = 1;
    # .latexmkrc ends
After that, by using M-x TeX-command-master (or C-c C-c), you can use
LatexMk command to compile TeX source.

For Japanese users:

LatexMk command automatically stores the encoding of a source file
and passes it to latexmk via an environment variable named "LATEXENC".
Here is the example of .latexmkrc to use "LATEXENC":
    # .latexmkrc starts
    $kanji    = "-kanji=$ENV{\"LATEXENC\"}" if defined $ENV{"LATEXENC"};
    $latex    = "platex $kanji";
    $bibtex   = "pbibtex $kanji";
    $dvipdf   = 'dvipdfmx -o %D %S';
    $pdf_mode = 3;
    # .latexmkrc ends

[back]
**** 有效参考[[https://blog.csdn.net/wdkirchhoff/article/details/41707157][在这里]] 其他的就需要自己去发现了
*** TODO 基本安装教程[/]
:LOGBOOK:  
CLOCK: [2019-05-05 日 10:03]--[2019-05-05 日 10:05] =>  0:02
:END:      

方案：emacs + textlive + auctex + sumatrapdf
按照[[https://blog.csdn.net/engreal/article/details/80704755][此博客]] 安装
更新源 报错
  (running on Debian, switching to user mode!)
  Cannot determine type of tlpdb from /home/work/texmf!
  cannot setup TLPDB in /home/work/texmf at /usr/bin/tlmgr line 6513.
 不想管这个问题了，过于麻烦，没什么用
sudo equivs-build texlive-local报错
  dh_testdir
  dh_testroot
  dh_prep
  dh_testdir
  dh_testroot
  dh_install
  dh_installdocs
  dh_installchangelogs
  dh_installchangelogs: 警告:     debian/changelog(l1): 格式损坏的头行
  LINE: |<|package name; defaults to equivs-dummy> (1.0) unstable; urgency=low
  dh_installchangelogs: 警告:     debian/changelog(l2): 在预想的 first heading 中发现空行
  dh_installchangelogs: 警告:     debian/changelog(l3): 在预想的 first heading 处发现更改的数据
  LINE:   * First version
  dh_installchangelogs: 警告: 未知信息 ''在输入 更新日志的已分析版本 中
  Can't locate object method "is_valid" via package "unknown" (perhaps you forgot to 
load "unknown"?) at /usr/share/perl5/Debian/Debhelper/Dh_Lib.pm line 1016.
  make: *** [debian/rules:24：binary-indep] 错误 255
  Error in the build process: exit status 2

***** 安装之后
group list：https://tug.org/usergroups.html

*****  Ubuntu下安装texlive并配置texstudio
2018年04月24日 22:09:00 My_leaf 阅读数：2159
版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/My_leaf/article/details/80071614

TeXLive 是由国际 TeX 用户组织 TUG 开发的 TeX 系统，支持不同的操作系统平台。其 Windows 版本又称 fpTeX,Unix/Linux 版本即著名的 teTeX 。
环境说明：
Ubuntu 16.04

******* 安装texlive
Ubuntu下 TeX Live 2018 的安装与配置
安装前准备

    下载texlive镜像
    https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/
    使用图形化安装界面，需要安装perl的tk组件
    sudo apt-get install perl-tk

安装TeX Live 2018
加载镜像文件

sudo mount -o loop texlive.iso /mnt
启动安装程序的图形化界面进行配置

cd /mnt
sudo ./install-tl -gui

点击完成，卸载镜像文件
cd /; sudo umount /mnt

******* 环境配置
划重点，安装后要进行环境变量等的配置
具体方法：
sudo gedit ~/.bashrc
在最后添加以下内容：

export MANPATH=${MANPATH}:/usr/local/texlive/2016/texmf-dist/doc/man
export INFOPATH=${INFOPATH}:/usr/local/texlive/2016/texmf-dist/doc/info
export PATH=${PATH}:/usr/local/texlive/2016/bin/x86_64-linux

    1
    2
    3

然后ctrl + s保存退出，输入source ~/.bashrc使更改生效。

******* 安装texstudio

在官方网站http://texstudio.sourceforge.net下载对应版本的deb安装包进行安装。
然后从option选项中进行配置
[[file:~/note/else/image/配置texstudio.png][配置界面]]
从右边的文件夹标志点进去选择就行，-src一类的附加内容会自己添加。
测试

新建tex文件，输入最基本的指令进行测试

\documentclass{article}

\begin{document}

  Hello latex!

\end{document}


成功后可以得到右边的编译结果。
注意如果不能编译中文，说明是build的编译器不行，推荐视同x类
***** TODO 使用emacs + textlive
*** 测试
[[file:text.txt][txt]]
* TODO emacs强化 我想让emacs 拥有什么功能？
*** TODO 解决右下角标记内容的方法
*** TODO 如何实现在目录中查找
*** TODO emacs的目录
在emacs的目录上添加一个功能
即con...
以应对新建目录中可能会存在的问题
|<|M-return> the command org-meta-return

初步使用宏解决了
以后可以尝试将宏绑定到 org-meta-return 上，但是不建议这么做，因为 org-meta-return上可能还有别的功能
但是可以尝试将M-enter直接与my绑定到一起
*** TODO 设置议程文件位置
SCHEDULED: |<|2019-04-14 日>
***** 方案一 fail
(setq org-directory "~/Documents/Dropbox/0.GTD/")
***** 方案二
要不要自定义一个文件然后链接出去
1. [ ] 测试自定义的文件能否被使用
2. [ ] 链接与复制，将文件内容复制到相应位置
3. [ ] 测试同步效果
co
*** TODO 默认插入时间
如何做到插入你需要的时间；比如是循环还是单日执行
初步计划：应当处理好如何对付循环的情况，
设计两个对应
| 键1          | 键2          |
|--------------+--------------|
| 插入单个日期 | 插入循环日期 |
|              |              |
| done单个日期 | done循环日期 |
***** test

*** TODO 在winemacs上安装词典

*** TODO [[file:%E8%AF%8D%E5%85%B8.org][sdcv词典]]
*** test
[[./testlisp.lisp]]
***** DONE test cs是不是出现问题l
CLOSED: [2019-10-07 一 10:49] SCHEDULED: <2019-10-12 六 20:00 >
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-10-07 一 10:49]
- State "DONE"       from "TODO"       [2019-10-07 一 10:49]
- State "DONE"       from "TODO"       [2019-10-07 一 10:49]
- State "DONE"       from "TODO"       [2019-10-07 一 10:49]
- State "DONE"       from "TODO"       [2019-10-07 一 10:49]
- State "DONE"       from "TODO"       [2019-10-07 一 10:49]
- State "DONE"       from "TODO"       [2019-10-06 日 09:18]
:END:      
:PROPERTIES:
:LAST_REPEAT: [2019-10-07 一 10:49]
:END:

暂时没有eeeeeeeeeee
*** TODO emacs 图片
1. [ ] emacs 怎么插入图片  
   1. 插入链接
   2. 允许拖动
   3. 允许剪切，复制粘贴
2. 显示图片与否
3. 控制图片大小
*** 等待使用
1. [ ] org-bable
2. [ ] 
*** TODO 任务序列
安排出一个任务序列表，体现出先后次序
*** TODO 添加询问
隔一段时间会问你几个问题
比如这个问题可能是一个因变量，也可可能是用于内容的统计，总之有其特殊的用处
*** TODO 处理电脑端是否同步图片
*** TODO 输入法跳动问题
多半是输入法和右下方的显示不匹配
*** DONE todo的更加快捷功能
CLOSED: [2019-06-01 六 11:16]
:LOGBOOK:  
- State "DONE"       from "TODO"       [2019-06-01 六 11:16]
:END:      

功能要求
  1. [X] 快捷插入循环shedule 
不过你需要首先找到能够用代码替代宏的方法
  1. 永久宏？
  2. 如何用lisp代替操作，需要看一看别人怎么写的
con 

*** 参考资查看料：

--------------------- 
作者：engreal 
来源：CSDN 
原文：https://blog.csdn.net/engreal/article/details/80704755 
版权声明：本文为博主原创文章，转载请附上博文链接！



--------------------- 
作者：skuldjf 
来源：CSDN 
原文：https://blog.csdn.net/skuldjf/article/details/78068111 
版权声明：本文为博主原创文章，转载请附上博文链接！
扩展阅读
手册第 10 章


作者：机械猿
链接：https://www.jianshu.com/p/0d1c26abb7e6
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

*** TODO 关于emacs的更多想法
:LOGBOOK:  
- State "WAIT"       from "TODO"       [2018-12-19 三 21:09] \\
  需要自己学会lisp之后搭建一个插件进行支持，自己写太费事了，，，让文本支持绘图，就像word一样会是一件繁复的工作
:END:      
直接做解决不了，只能初步，靠插入图片来解决吗？
或者说写一个orgmode的第二模式？支持笔画？
- [X] 标记与突出 下划线 加粗 右下标
- [X] 有没有行标记 使用特定的文字输入搭配搜索zhang+（？+：链接等等）
- [ ] 如何达到画笔的表现力 随处标记，
- [ ] 方便程
- [ ] c-s 添加默认情况 请参考词典

eeeee
*** TODO 将 参考资料绑定到命令上

*** TODO emacs 的分屏还是太弱了 需要强化
